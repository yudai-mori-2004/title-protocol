# Title Protocol — EC2 デプロイ手順書

新規EC2インスタンスにTitle Protocolをゼロからデプロイする手順。
Mock TEE（Enclaveなし）と Nitro TEE（実Enclave）の2パターンを記載。

---

## 目次

1. [前提条件](#1-前提条件)
2. [AWS インフラ構築（Terraform）](#2-aws-インフラ構築terraform)
3. [EC2 初期セットアップ](#3-ec2-初期セットアップ)
4. [リポジトリ準備と .env 設定](#4-リポジトリ準備と-env-設定)
5. [A: Mock TEE でデプロイ](#5a-mock-tee-でデプロイ)
6. [B: Nitro TEE でデプロイ](#5b-nitro-tee-でデプロイ)
7. [Global Config 初期化](#6-global-config-初期化)
8. [動作確認（experiments/register-photo.ts）](#7-動作確認)
9. [トラブルシューティング](#8-トラブルシューティング)
10. [アーキテクチャ図](#9-アーキテクチャ図)

---

## 1. 前提条件

### ローカルマシン

- AWS CLI 設定済み（`aws configure`）
- Terraform >= 1.5
- SSH キーペアが AWS に登録済み
- Node.js >= 20、Solana CLI
- Solana devnet ウォレットに SOL あり（`~/.config/solana/id.json`）

### AWS アカウント

- **Nitro Enclave 対応インスタンスが使えるリージョン**（ap-northeast-1 推奨）
- Nitro Enclave 対応インスタンスタイプ: `c5.xlarge` 以上（4 vCPU必須。Enclaveに2 vCPU割当てるため）
- **Helius の Solana RPC API キー**（https://helius.dev/ で無料取得可、devnetは無料枠あり）

---

## 2. AWS インフラ構築（Terraform）

Terraform で EC2 + S3 + IAM + Security Group を一括作成する。

### 2.1 SSH キーペアの準備

```bash
# ローカルで作成する場合
mkdir -p deploy/aws/keys
aws ec2 create-key-pair \
  --key-name title-protocol-devnet \
  --query 'KeyMaterial' \
  --output text > deploy/aws/keys/title-protocol-devnet.pem
chmod 400 deploy/aws/keys/title-protocol-devnet.pem
```

既存のキーペアがあれば `--key-name` をそれに合わせる。

### 2.2 Terraform 実行

```bash
cd deploy/aws/terraform
terraform init
terraform plan
terraform apply
```

出力される値をメモ:

```
instance_public_ip    = "XX.XX.XX.XX"
s3_bucket_name        = "title-uploads-devnet"
s3_bucket_endpoint    = "https://s3.ap-northeast-1.amazonaws.com"
s3_access_key_id      = "AKIA..."
s3_secret_access_key  = <sensitive>
ssh_command           = "ssh -i ../keys/title-protocol-devnet.pem ec2-user@XX.XX.XX.XX"
```

S3 シークレットキーの取得:

```bash
terraform output -raw s3_secret_access_key
```

### 2.3 変数カスタマイズ（任意）

```bash
terraform apply \
  -var="key_name=my-key" \
  -var="instance_type=c5.xlarge" \
  -var="enclave_cpu_count=2" \
  -var="enclave_memory_mib=1024"
```

**作成されるリソース:**

| リソース | 用途 |
|---------|------|
| EC2 (c5.xlarge) | TEE + Gateway + Indexer 全部入り |
| S3 バケット | 暗号化ペイロード一時保管（1日で自動削除） |
| IAM ロール | EC2 → S3 アクセス権限 |
| IAM ユーザー + アクセスキー | Gateway → S3 presigned URL 生成用（永続キー） |
| Security Group | SSH(22) + Gateway(3000) + Indexer(5000) のみ許可 |

> **Note:** TEE port 4000 は Security Group で外部公開されない（意図的）。
> Gateway がホスト内で TEE に中継するため、外部からは Gateway:3000 のみでOK。

---

## 3. EC2 初期セットアップ

Terraform の `user-data.sh` が初回起動時に自動実行され、以下をインストール:
- Docker + Docker Compose plugin
- Nitro Enclaves CLI + Allocator
- Node.js 20, Git, gcc/g++, socat, Rust, wasm32 ターゲット, Solana CLI

### 3.1 SSH 接続

```bash
ssh -i deploy/aws/keys/title-protocol-devnet.pem ec2-user@<PUBLIC_IP>
```

### 3.2 初期セットアップ完了の確認

`user-data.sh` は数分かかる。完了確認:

```bash
# ログで確認
tail -f /var/log/title-setup.log
# 「=== 初期セットアップ完了 ===」が出れば OK

# 各ツールの確認
docker --version           # Docker 25+
docker compose version     # v2.27+
nitro-cli --version        # 1.4+
node --version             # v20.x
cargo --version            # 1.x
rustup target list --installed | grep wasm32  # wasm32-unknown-unknown
```

> **Note:** `setup-ec2.sh` は Docker グループ未反映を検出し、自動で `sg docker` 経由で再実行するため、再ログインは不要。

### 3.3 Nitro Allocator の確認（Nitro モードの場合のみ）

```bash
cat /etc/nitro_enclaves/allocator.yaml
# memory_mib: 1024
# cpu_count: 2

systemctl status nitro-enclaves-allocator  # active (running)
```

---

## 4. リポジトリ準備と .env 設定

### 4.1 リポジトリのクローン

```bash
cd ~
git clone https://github.com/<your-org>/title-protocol.git
cd title-protocol
```

### 4.2 .env の作成

```bash
cp .env.example .env
vim .env
```

**必須設定:**

```bash
# --- 共通 ---
SOLANA_RPC_URL=https://devnet.helius-rpc.com/?api-key=YOUR_HELIUS_KEY

# --- Gateway ---
GATEWAY_SIGNING_KEY=$(openssl rand -hex 32)   # ← 実行して出た値を貼る
S3_ENDPOINT=https://s3.ap-northeast-1.amazonaws.com
S3_PUBLIC_ENDPOINT=https://s3.ap-northeast-1.amazonaws.com
S3_ACCESS_KEY=<terraform output s3_access_key_id の値>
S3_SECRET_KEY=<terraform output -raw s3_secret_access_key の値>
S3_BUCKET=title-uploads-devnet                 # Terraform出力の値

# --- TEE ---
TEE_RUNTIME=mock                               # Mock の場合
MOCK_MODE=true                                 # Mock の場合
PROXY_ADDR=direct                              # Mock の場合
TRUSTED_EXTENSIONS=phash-v1,hardware-google,c2pa-training-v1,c2pa-license-v1
WASM_DIR=/wasm-modules

# --- DB ---
DB_USER=title
DB_PASSWORD=$(openssl rand -base64 24)         # ← 実行して出た値を貼る

# --- Indexer ---
DATABASE_URL=postgres://title:<上のDB_PASSWORD>@localhost:5432/title_indexer
DAS_ENDPOINTS=https://devnet.helius-rpc.com/?api-key=YOUR_HELIUS_KEY
```

> **Mock / Nitro で変える値は Step 5 の中で指示します。**

### 4.3 Solana ウォレットの設定

`setup-ec2.sh` がウォレット未作成を検出し自動作成するため、手動作成は不要。
ただし SOL の送金は手動で行う必要がある:

```bash
# devnet SOL のエアドロップ（レート制限あり、失敗したらローカルから送金）
solana config set --url devnet
solana airdrop 2
solana balance

# ローカルから送金する場合:
# solana transfer <EC2ウォレット公開鍵> 5 --url devnet
```

---

## 5A. Mock TEE でデプロイ

Mock TEE は Enclave を使わず、TEE バイナリを直接ホストで実行する。
開発・テスト目的で使い、attestation は `tee_type: "mock"` + ゼロ PCR になる。

### 5A.1 .env の確認

```bash
# Mock 用の値が設定されていることを確認
grep -E '^(TEE_RUNTIME|MOCK_MODE|PROXY_ADDR)' .env
# TEE_RUNTIME=mock
# MOCK_MODE=true
# PROXY_ADDR=direct
```

### 5A.2 Rust バイナリのビルド

```bash
export OPENSSL_NO_VENDOR=1
cargo build --release --bin title-tee --bin title-gateway --bin title-proxy
```

初回は約13分かかる。

### 5A.3 WASM モジュールのビルド

```bash
mkdir -p wasm-modules
for module in phash-v1 hardware-google c2pa-training-v1 c2pa-license-v1; do
  (cd "wasm/$module" && cargo build --target wasm32-unknown-unknown --release)
  cp "wasm/$module/target/wasm32-unknown-unknown/release/${module//-/_}.wasm" "wasm-modules/$module.wasm"
done
ls -la wasm-modules/
# 4つの .wasm ファイルがあればOK
```

### 5A.4 TEE (Mock) の起動

```bash
set -a && source .env && set +a

MOCK_MODE=true TEE_RUNTIME=mock PROXY_ADDR=direct \
  SOLANA_RPC_URL="$SOLANA_RPC_URL" \
  TRUSTED_EXTENSIONS="$TRUSTED_EXTENSIONS" \
  WASM_DIR="$(pwd)/wasm-modules" \
  nohup ./target/release/title-tee > /tmp/title-tee.log 2>&1 &

echo "TEE PID: $!"
sleep 2
curl -s http://localhost:4000/health
# → "ok"
```

### 5A.5 Gateway + PostgreSQL + Indexer の起動

```bash
set -a && source .env && set +a
docker compose -f deploy/aws/docker-compose.production.yml up -d --build
```

起動待ち:

```bash
for i in $(seq 1 30); do
  curl -sf http://localhost:3000/.well-known/title-node-info && break
  sleep 2
done
```

### 5A.6 ヘルスチェック

```bash
echo "--- Gateway ---"
curl -s http://localhost:3000/.well-known/title-node-info | python3 -m json.tool

echo "--- TEE ---"
curl -s http://localhost:4000/health

echo "--- Indexer ---"
curl -s http://localhost:5000/health
```

3つ全て応答すればMockデプロイ完了。→ [6. Global Config 初期化](#6-global-config-初期化) へ。

---

## 5B. Nitro TEE でデプロイ

Nitro TEE は AWS Nitro Enclave 内で TEE を実行する。
attestation は `tee_type: "aws_nitro"` + 実 PCR 値 + AWS 証明書チェーン付き COSE Sign1 になる。

### アーキテクチャの理解

Nitro Enclave は**完全に隔離されたVM**であり:
- ホストのファイルシステムにアクセス不可
- TCP ネットワークなし（vsock のみ）
- loopback (127.0.0.1) もデフォルトで無効

そのため、3つの追加メカニズムが必要:
1. **socat ブリッジ** — TCP ↔ vsock の変換（ホスト側 + Enclave 内側の 2 箇所）
2. **.env ベイク** — Docker イメージに .env を含める
3. **title-proxy** — TEE からの外部通信を vsock 経由で中継

```
Client → Gateway(:3000)
           ↓ HTTP
         socat(ホスト TCP:4000 → vsock:CID:4000)
           ↓ vsock
         socat(Enclave vsock:4000 → TCP:localhost:4000)
           ↓ loopback
         title-tee(:4000)
           ↓ loopback
         socat(Enclave TCP:8000 → vsock:3:8000)
           ↓ vsock
         title-proxy(ホスト vsock:8000)
           ↓ HTTPS
         Solana RPC / S3 / etc.
```

### 5B.1 .env の設定

Mock との違いは TEE_RUNTIME / MOCK_MODE / PROXY_ADDR の3つだけ。
**ただし .env の全設定が必要**（Enclave 内に .env ごとベイクされるため）:

```bash
vim .env
```

```bash
# TEE 設定（Nitro用に変更）
TEE_RUNTIME=nitro          # ← "mock" から変更不要（entrypoint.sh が強制上書きする）
MOCK_MODE=false            # ← 参考値（entrypoint.sh が TEE_RUNTIME=nitro に上書き）
PROXY_ADDR=127.0.0.1:8000  # ← 参考値（entrypoint.sh が上書き）
```

> **重要:** `entrypoint.sh` が Enclave 内で `TEE_RUNTIME=nitro`, `PROXY_ADDR=127.0.0.1:8000`,
> `WASM_DIR=/wasm-modules` を**強制上書き**するので、.env のこれらの値が mock のままでも Nitro で動く。
> ただし混乱を防ぐため、.env 側も合わせておくことを推奨。

### 5B.2 Rust バイナリのビルド

```bash
export OPENSSL_NO_VENDOR=1
cargo build --release --bin title-tee --bin title-gateway --bin title-proxy
```

### 5B.3 WASM モジュールのビルド

```bash
mkdir -p wasm-modules
for module in phash-v1 hardware-google c2pa-training-v1 c2pa-license-v1; do
  (cd "wasm/$module" && cargo build --target wasm32-unknown-unknown --release)
  cp "wasm/$module/target/wasm32-unknown-unknown/release/${module//-/_}.wasm" "wasm-modules/$module.wasm"
done
ls -la wasm-modules/
# 4つの .wasm ファイルがあればOK
```

### 5B.4 Docker イメージ + EIF のビルド

```bash
# Docker イメージをビルド（.env と wasm-modules/ が COPY される）
docker build -t title-tee-enclave -f deploy/aws/docker/tee.Dockerfile .

# EIF（Enclave Image Format）に変換
nitro-cli build-enclave \
  --docker-uri title-tee-enclave:latest \
  --output-file ./title-tee.eif
```

PCR 値が表示される。これは attestation に含まれる測定値:

```
PCR0: 28f72a80...  ← コード + Docker レイヤー
PCR1: 4b4d5b36...  ← カーネル
PCR2: 5c7cc94f...  ← アプリケーション
```

> **Note:** .env やコードを変更するたびに PCR 値は変わる。
> Docker キャッシュが効けば rebuild は数秒。フルビルドは約13分。

### 5B.5 既存 Enclave の停止（再デプロイ時のみ）

```bash
EXISTING=$(nitro-cli describe-enclaves | python3 -c "
import sys, json
for e in json.load(sys.stdin):
    if e.get('State') == 'RUNNING':
        print(e['EnclaveID'])
" 2>/dev/null || true)

if [ -n "$EXISTING" ]; then
  nitro-cli terminate-enclave --enclave-id "$EXISTING"
  pkill -f "socat TCP-LISTEN:4000" 2>/dev/null || true
  sleep 2
fi
```

### 5B.6 Enclave の起動

```bash
ENCLAVE_OUTPUT=$(nitro-cli run-enclave \
  --eif-path ./title-tee.eif \
  --cpu-count 2 \
  --memory 1024 \
  --debug-mode)

echo "$ENCLAVE_OUTPUT"
# → {"EnclaveName":"...","EnclaveCID":18,...}

ENCLAVE_CID=$(echo "$ENCLAVE_OUTPUT" | python3 -c "import sys,json; print(json.load(sys.stdin)['EnclaveCID'])")
echo "Enclave CID: $ENCLAVE_CID"
```

### 5B.7 ホスト側 socat ブリッジの起動

```bash
# Gateway(TCP:4000) → Enclave(vsock:CID:4000) のインバウンドブリッジ
socat TCP-LISTEN:4000,fork,reuseaddr VSOCK-CONNECT:$ENCLAVE_CID:4000 &
echo "インバウンドブリッジ起動完了"
```

> Enclave 内側のブリッジ（vsock:4000→localhost:4000、localhost:8000→vsock:3:8000）は
> `entrypoint.sh` が自動起動する。

### 5B.8 Enclave コンソールログの確認

```bash
# 別ターミナルで実行（Ctrl+C で抜ける）
nitro-cli console --enclave-id $(nitro-cli describe-enclaves | python3 -c "
import sys,json; [print(e['EnclaveID']) for e in json.load(sys.stdin) if e.get('State')=='RUNNING']
")
```

以下のログが出れば正常:

```
[INFO] title_tee: NitroRuntimeで起動します
[INFO] title_tee: ファイル WASMローダーを使用します wasm_dir=/wasm-modules
[INFO] title_tee: 鍵を生成中...
[INFO] title_tee: 鍵生成完了
[INFO] title_tee: TEEサーバーを 0.0.0.0:4000 で起動します (inactive状態)
```

### 5B.9 title-proxy の起動

TEE が外部 API（Solana RPC, S3 等）にアクセスするための vsock プロキシ:

```bash
nohup ./target/release/title-proxy > /tmp/title-proxy.log 2>&1 &
echo "Proxy PID: $!"
cat /tmp/title-proxy.log
# → [INFO] title_proxy: vsock HTTPプロキシを port 8000 で起動します
```

### 5B.10 ヘルスチェック（TEE）

```bash
curl -s http://localhost:4000/health
# → "ok"
```

これが通れば、ホスト → socat → vsock → Enclave → socat → TEE の**全経路が開通**している。

### 5B.11 Gateway + PostgreSQL + Indexer の起動

```bash
set -a && source .env && set +a
docker compose -f deploy/aws/docker-compose.production.yml up -d --build
```

起動待ち:

```bash
for i in $(seq 1 30); do
  curl -sf http://localhost:3000/.well-known/title-node-info && break
  sleep 2
done
```

### 5B.12 全サービスのヘルスチェック

```bash
echo "--- Gateway ---"
curl -s http://localhost:3000/.well-known/title-node-info | python3 -m json.tool

echo "--- TEE ---"
curl -s http://localhost:4000/health

echo "--- Indexer ---"
curl -s http://localhost:5000/health
```

3つ全て応答すれば Nitro デプロイ完了。→ [6. Global Config 初期化](#6-global-config-初期化) へ。

---

## 6. Global Config 初期化

Global Config（Solana上の設定PDA）と Merkle Tree（cNFT用）を作成する。
**Mock / Nitro 共通の手順。**

### 6.1 init-config.mjs の実行

```bash
# EC2 上で実行
cd ~/title-protocol

# npm依存のインストール（初回のみ）
cd scripts && npm install --silent && cd ..

# RPC URLを .env から読み込み
set -a && source .env && set +a

# 初期化実行
node scripts/init-config.mjs \
  --rpc "$SOLANA_RPC_URL" \
  --gateway http://localhost:3000 \
  --tee http://localhost:4000
```

出力例:

```
Authority: wrVwsTuRzbsDutybqqpf9tBE7JUqRPYzJ3iPUgcFmna
Global Config PDA: W4AYqC9sFpuHz8LbeuB8jtxNReUkGkjzrWr3EUftsWZ
TEE signing_pubkey: 8fMFjKRTNtjjvFWJUqbkruaZCDoEXf3VxT4xppEwRRLy
Merkle Tree 作成完了: GkMoRgwYCrnaPFkfAmrA5veVA2g1AQtvzN86JVuNNAwX
TEE情報を保存: .../tests/e2e/fixtures/tee-info.json
```

### 6.2 TEE 情報の確認

```bash
cat tests/e2e/fixtures/tee-info.json | python3 -m json.tool
```

```json
{
    "tree_address": "GkMoRgwY...",
    "signing_pubkey": "8fMFjKRT...",
    "encryption_pubkey": "em4AeBcv..."
}
```

`encryption_pubkey` は後の動作確認で使う。メモしておく。

> **Note:** TEE を再起動すると鍵が再生成される（ステートレス設計）。
> その場合は `init-config.mjs` を再実行して新しい Merkle Tree を作成する必要がある。

---

## 7. 動作確認

### 7.1 experiments/register-photo.ts の実行

**ローカルマシンから**実行する。EC2 の Gateway:3000 に対してリクエストを送る。

```bash
# ローカルマシンで実行
cd experiments

# 依存インストール（初回のみ）
npm install

# 実行
npx tsx register-photo.ts <EC2_PUBLIC_IP> <画像パス> \
  --wallet ~/.config/solana/id.json \
  --rpc "https://devnet.helius-rpc.com/?api-key=YOUR_KEY" \
  --encryption-pubkey "<tee-info.json の encryption_pubkey>"
```

実行例:

```bash
npx tsx register-photo.ts 35.78.104.174 "../--help/pixel_photo_ramen.jpg" \
  --wallet ~/.config/solana/id.json \
  --rpc "https://devnet.helius-rpc.com/?api-key=7b263012-xxxx" \
  --encryption-pubkey "em4AeBcvUgrCrugqtiJ7KqjXKnGbFmbNtdCjGUY6WVc="
```

> **`--encryption-pubkey` が必要な理由:**
> Security Group で TEE port 4000 は外部公開されていない。
> SDK は通常 `/tee-info` エンドポイントから encryption_pubkey を取得するが、
> 外部からは到達できないため CLI 引数で直接指定する。

### 7.2 期待される出力

```
[12:01:14] STEP 1 node-info を取得中...
[12:01:14] STEP 3 暗号化完了 → S3にアップロード
[12:01:17] STEP 4 /verify 完了 (436ms)
  tee_type:       aws_nitro        ← Nitro の場合
  tee_type:       mock             ← Mock の場合
  content_hash:   0xf44718...
[12:01:20] STEP 5 Arweaveにアップロード → https://gateway.irys.xyz/...
[12:01:21] STEP 6 /sign 完了 (1303ms)
[12:01:21] DONE 全結果を保存: output-register.json
```

### 7.3 結果の確認

```bash
cat output-register.json | python3 -m json.tool
```

**Mock の場合:**

```json
{
  "verify": {
    "results": [{
      "signed_json": {
        "tee_type": "mock",
        "tee_attestation": "eyJtb2R1bGV..."   // Base64 JSON、全 PCR がゼロ
      }
    }]
  }
}
```

**Nitro の場合:**

```json
{
  "verify": {
    "results": [{
      "signed_json": {
        "tee_type": "aws_nitro",
        "tee_attestation": "hEShATgio..."     // COSE Sign1、実 PCR + AWS 証明書チェーン
      }
    }]
  }
}
```

### 7.4 その他のオプション

```bash
# verify のみ（sign スキップ）
npx tsx register-photo.ts <IP> <image> --wallet <key> --skip-sign

# verify + sign + broadcast（実際に cNFT をオンチェーン発行）
npx tsx register-photo.ts <IP> <image> --wallet <key> --broadcast

# 特定の processor のみ
npx tsx register-photo.ts <IP> <image> --wallet <key> --processors core-c2pa,phash-v1
```

---

## 8. トラブルシューティング

### Enclave 内で `Network is unreachable`

```
socat[600] E connect(5, AF=2 127.0.0.1:4000, 16): Network is unreachable
```

**原因:** Enclave 内で loopback インターフェースが未有効化。
**修正:** `entrypoint.sh` に以下があることを確認:

```sh
ifconfig lo 127.0.0.1 netmask 255.0.0.0 up 2>/dev/null \
  || (ip addr add 127.0.0.1/8 dev lo && ip link set lo up) 2>/dev/null \
  || true
```

`tee.Dockerfile` に `iproute` パッケージがあることも確認。

### TEE `/verify` で `early eof`

```
HTTP 502 - 外部通信に失敗: IOエラー: early eof
```

**原因:** title-proxy が起動していない。TEE が S3 からファイルをダウンロードできない。
**修正:** proxy を起動する:

```bash
nohup ./target/release/title-proxy > /tmp/title-proxy.log 2>&1 &
cat /tmp/title-proxy.log  # "vsock HTTPプロキシを port 8000 で起動" を確認
```

### Docker Compose でポート衝突

```
Bind for 127.0.0.1:5432 failed: port is already allocated
```

**原因:** 前回の compose が残っている。
**修正:**

```bash
docker ps -a  # 動いているコンテナを確認
docker stop <old-container> && docker rm <old-container>
# その後再度 docker compose up
```

### `curl localhost:4000/health` が応答しない

1. **Mock:** TEE プロセスが起動しているか確認: `pgrep -x title-tee`
2. **Nitro:** Enclave が RUNNING か確認: `nitro-cli describe-enclaves`
3. **Nitro:** ホスト側 socat が動いているか: `pgrep -f "socat TCP-LISTEN:4000"`
4. **Nitro:** コンソールログ確認: `nitro-cli console --enclave-id <ID>`

### Helius API キーエラー (`401 Unauthorized`)

```
Error: 401 Unauthorized: Invalid API key
```

**修正:** https://helius.dev/ でキーを確認し、.env の `SOLANA_RPC_URL` を更新。

### init-config.mjs が失敗する

```
Error: Blockhash not found
```

**修正:** Solana RPC の接続確認:

```bash
curl -X POST -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"getHealth"}' \
  "$SOLANA_RPC_URL"
# → {"jsonrpc":"2.0","result":"ok","id":1}
```

---

## 9. アーキテクチャ図

### Mock モード

```
Client → Gateway(:3000) → TEE(:4000) → Solana RPC (直接HTTP)
              ↓                ↑
         PostgreSQL       wasm-modules/
         S3 (AWS)
```

TEE はホスト上で裸のRustバイナリとして動作。外部通信は直接HTTP。

### Nitro モード

```
Client → Gateway(:3000)
              ↓ HTTP
         ┌─── socat (ホスト TCP:4000 → vsock:CID:4000) ───┐
         │                                                  │
         │    ┌──────── Nitro Enclave ─────────┐           │
         │    │ socat (vsock:4000→localhost:4000)│           │
         │    │          ↓                      │           │
         │    │   title-tee (:4000)             │           │
         │    │          ↓                      │           │
         │    │ socat (localhost:8000→vsock:3:8000)         │
         │    └─────────────────────────────────┘           │
         │                                                  │
         └─── title-proxy (ホスト vsock:8000) ─────────────┘
                     ↓ HTTPS
              Solana RPC / S3 / etc.
```

TEE は Enclave 内の隔離 VM で動作。全通信は vsock + socat ブリッジ経由。

### 主要ファイル一覧

| ファイル | 役割 |
|---------|------|
| `deploy/aws/terraform/` | EC2 + S3 + IAM のインフラ定義 |
| `deploy/aws/terraform/user-data.sh` | EC2 初回起動時の自動セットアップ |
| `deploy/aws/setup-ec2.sh` | 全自動デプロイスクリプト（Step 0〜8） |
| `deploy/aws/docker/tee.Dockerfile` | Enclave 用 Docker イメージ |
| `deploy/aws/docker/entrypoint.sh` | Enclave 内エントリポイント（loopback + socat + TEE起動） |
| `deploy/aws/docker-compose.production.yml` | Gateway + PostgreSQL + Indexer |
| `.env.example` | 環境変数テンプレート |
| `scripts/init-config.mjs` | Global Config + Merkle Tree 初期化 |
| `experiments/register-photo.ts` | 動作確認用 E2E スクリプト |

### setup-ec2.sh について

`deploy/aws/setup-ec2.sh` は上記の手動手順を**全自動で実行**するスクリプト。
`.env` が設定済みであれば、以下の1コマンドで Mock / Nitro を自動判定してデプロイできる:

```bash
cd ~/title-protocol
./deploy/aws/setup-ec2.sh
```

`nitro-cli` がインストールされていれば Nitro モード、なければ Mock モードで起動する。
本手順書はこのスクリプトの内部動作を分解して説明したもの。
