# Title Protocol 技術仕様書 ver.9

**"The Identity Layer for Digital Content"**

---

# 0. 前提

## 0.1 用語の定義

本文書において「デジタルコンテンツのアイデンティティ」とは、以下の三条件を全て満たす状態を指す。

| 条件 | 説明 |
| --- | --- |
| 来歴（Provenance） | コンテンツの出自・作成過程が暗号学的に検証可能である |
| 同一性（Integrity） | コンテンツ自体が改ざんされていないことを検知可能である |
| 帰属（Attribution） | コンテンツの権利の所在がトラストレスに解決可能である |

## 0.2 Title Protocolの位置づけ

C2PA（Coalition for Content Provenance and Authenticity）は、Adobe、Microsoft、Intel等が策定したデジタルコンテンツの来歴証明規格である。コンテンツに署名付きメタデータを埋め込み、「誰が、いつ、どのツールで作成・編集したか」を暗号学的に証明する。

C2PAは、来歴と同一性を解決した。Title Protocolは、帰属を解決する。

| 項目 | 名称 | 解決する条件 |
| --- | --- | --- |
| 既存規格 | C2PA | 来歴（Provenance）、同一性（Integrity） |
| 本プロトコル | Title Protocol | 帰属（Attribution） |

C2PAとTitle Protocolが組み合わさることで、デジタルコンテンツは初めて完全なアイデンティティを獲得する。

## 0.3 設計原則

| 原則 | 説明 |
| --- | --- |
| Content-Agnostic | コンテンツの生データはプロトコルの運営者や各ノードの管理者は感知できない |
| Stateless | TEE（Trusted Execution Environment: 信頼された実行環境）はリクエスト間で状態を持たず、入力データと計算のみに基づいて結果を返す |
| Neutral | 特定のアプリケーションに依存しない公共インフラである |
| Permissionless | 誰でもプロトコルを利用したアプリケーションを構築できる。プロトコルの運営ノードはDAO（分散型自律組織）によって管理され、特定の権力や組織に依存しない設計である |
| Smart-Contract-Less | 独自のMintロジックを持たず、Metaplex Bubblegum（Solana上の圧縮NFT標準）の標準機能をそのまま活用する |

## 0.4 本文書の構成

本文書は、番号が大きくなるほど具体的な情報を扱う構成を採る。

| セクション | 内容 |
| --- | --- |
| **1. プロトコルモデル** | 最も抽象的な登録・検証フロー。特定の検証規格に依存しない汎用モデル |
| **2. Core** | C2PA検証をCoreに導入し、コンテンツ間の権利構造を獲得する |
| **3. Extension** | Coreと同じフローで任意の属性を付与する仕組み |
| **4. 運用モデル** | ユースケース、プロトコルの境界、設計上の割り切り |
| **5. 以降** | データ構造、API仕様、暗号パラメータ等の実装詳細 |

## 補足：Webインフラストラクチャとの対比による概念モデル

*本セクションは、技術的背景が異なる読者にも直感的にプロトコルの位置づけを理解できるよう、意図的に平易な敬体で記述している。*

現在のWeb（インターネット）が安全かつ便利に機能しているのは、HTTPなどの通信プロトコルだけでなく、その背後に強固な「信頼のインフラ」が存在するからです。

本プロトコルの役割は、Webにおける既存のインフラ技術と対比することで明確に定義できます。

C2PAとTitle Protocolの関係は、Webにおける**「SSL/TLS証明書」**と、それを支える**「運用インフラ（CTログ・DNS）」**の関係に相当します。

### インフラストラクチャ対比表

| **機能・役割** | **Webの世界 (TLS/DNS)** | **デジタルコンテンツの世界 (C2PA/Title)** |
| --- | --- | --- |
| **保護対象** | 通信経路（サーバーとの接続） | コンテンツ自体（画像・動画データ） |
| **身分証明書** | **SSL/TLSサーバー証明書**
（X.509規格）
通信先が意図したドメイン（サーバー）であることを証明する | **C2PAマニフェスト**
（C2PA規格）
データの来歴に改ざんがなく、同一性の担保されたコンテンツであることを証明する |
| **監査ログ** | **Certificate Transparency (CT) ログ**
証明書の発行履歴を監視する公開台帳 | **Title Protocol (Core Layer)**
TEE検証結果を刻むブロックチェーン台帳 |
| **宛先解決** | **DNS (Domain Name System)**
ドメイン名からIPアドレス（場所）を解決 | **Title Protocol (Resolve)**
コンテンツに記録されたC2PAのデータに基づく識別子からブロックチェーンウォレット（権利者のSolanaウォレットアドレス）を解決 |

### 1. 「身分証明書」としてのC2PA

Webサイトにアクセスする際、ブラウザに鍵マーク（SSL/TLS）が表示されるのは、認証局が発行した「証明書」によって接続先の真正性が保証されているからです。

デジタルコンテンツにおいてこの役割を担うのが**C2PA**です。カメラや編集ソフトが発行元となり、ファイルに署名付きのマニフェスト（身分証）を埋め込むことで、「このデータは確かにその機器で作成され、改ざんされていない」ことを証明します。

### 2. 「監査ログ（CTログ）」としてのTitle Protocol Core

Webには、正規の認証局から不正に証明書が発行されるリスクを防ぐため、すべての発行記録を透明な台帳に記録する**Certificate Transparency (CT) ログ**という仕組みが義務付けられています。ブラウザは、このログに存在しない証明書を信頼しません。

C2PA単体にはこの「公的な記録台帳」が存在しません。Title ProtocolのCoreレイヤーは、中立な計算機（TEE）が検証した事実をブロックチェーンに記録することで、CTログと同等の「改ざん不可能な監査ログ」として機能します。

### 3. 「宛先解決（DNS）」としてのTitle Protocol Resolve

Webでは、`google.com` という名前（ID）だけではサーバーに到達できず、**DNS**を使用して実際の住所である「IPアドレス」を割り出す（解決する）必要があります。
同様に、C2PAにはコンテンツの識別子はあっても、「現在誰が権利を持っているか（送金先）」は記録されていません。Title Protocolは、コンテンツの固有IDを**ドメイン名**、権利者のウォレットアドレスを**IPアドレス**に見立て、IDから現在の権利者の場所を解決する、DNSと同等の機能を提供します。

### まとめ

Webの世界が「SSL」だけでなく「CTログ」や「DNS」によって支えられているように、デジタルコンテンツのアイデンティティも「C2PA」だけでは完結しません。

C2PAがコンテンツの来歴・同一性を保証する「証明書」であるならば、Title Protocolはそれを社会的に運用し、権利を解決するための「インフラ（監査台帳・DNS）」を提供するものです。

# 1. プロトコルモデル

本セクションでは、Title Protocolの動作モデルをその最も抽象的な形から定義する。具体的なデータ構造、API仕様、暗号パラメータは後続セクションで詳述する。

---

### 用語の定義

| 用語 | 説明 |
| --- | --- |
| ウォレット | ブロックチェーン上の資産を管理する暗号鍵のペア。公開鍵がアドレス（識別子）として機能する |
| Solana | 高速・低コストを特徴とするブロックチェーン。本プロトコルの記録層として使用 |
| cNFT | Compressed NFT。Solana上でMerkle Treeを用いて大量発行を低コストで実現するNFT規格 |
| DAO | Decentralized Autonomous Organization。スマートコントラクトによって運営される分散型組織 |
| ガス代 | ブロックチェーンへの書き込み時に必要な手数料 |
| 権利トークン | 本プロトコルにおいて、コンテンツの帰属を表すcNFTを指す。本文書ではcNFTと権利トークンを同義で使用する |
| signed_json
（署名済みJSON） | TEEが検証結果をJSON形式でまとめ、自身の秘密鍵で署名したデータオブジェクト。オフチェーンストレージに保存された状態を指す場合は「オフチェーンデータ」とも称する |

---

## 1.1 登録モデル（Register）

### 概念モデル

Title Protocolが実現する登録処理は、概念的には極めて単純である。

```
User (wallet)        Client         Neutral Computer       Blockchain
     │                 │                  │                     │
     │  content        │                  │                     │
     │  wallet addr    │                  │                     │
     │  verify type    │                  │                     │
     │                 │                  │                     │
     │────────────────>│─────────────────>│                     │
     │                 │                  │                     │
     │                 │                  │── extract ─────────>│
     │                 │                  │── sign ───────────->│
     │                 │                  │── record (wallet) ->│
     │                 │                  │                     │
     
     

```

ウォレットを持つユーザーが、コンテンツとその帰属先ウォレット（ユーザーのウォレット）、行いたい検証の種類を、クライアント経由で中立な計算機に送る。計算機はコンテンツの生データから客観的な情報を抽出し、自身の秘密鍵で署名した上で、ユーザーのウォレットに帰属する形でブロックチェーンに記録する。

計算機の署名が記録に信頼を付与する。第三者は、ブロックチェーン上の記録と計算機の公開鍵を用いて、「この情報は確かにあの計算機が検証した結果である」ことを事後的に確認できる。

これが理想モデルであり、実際にはそのまま実装できない。計算機にデータを安全に届ける方法、計算機の中立性の担保、ブロックチェーンへの書き込みコスト——これらの制約を順に解決していく。

### 現実の登場人物

理想モデルを実装可能な形に分解すると、以下の登場人物が現れる。

| 分類 | 構成要素 | 役割 |
| --- | --- | --- |
| クライアントサイド | エンドユーザー（ウォレット保持）、クライアント（SDK） | コンテンツの暗号化・送信、トランザクションの署名 |
| 登録ノード | Gateway, Temporary Storage, TEE | 認証・中継・一時保管、コンテンツ検証・署名 |
| ストレージ | オフチェーンストレージ（Arweave等） | `signed_json` の永続保存。Arweaveは永続的なデータ保存を保証する分散型ストレージ |
| ブロックチェーン | Solana | 権利トークン（cNFT）による権利の記録 |
| ガバナンス | DAO | 信頼の原点（Collection Authorityの保持） |

Gateway、Temporary Storage、TEEの三者をまとめて **登録ノード** と呼ぶ。登録ノードは誰でも構築・運用できる。

---

### 登録ノード側の要求——TEEの保護

理想モデルにおける「中立な計算機」の実体はTEE（Trusted Execution Environment）である。TEEの内部処理は暗号学的に保護されるが、TEEをインターネットに直接晒すことはDDoS攻撃やサイドチャネル攻撃のリスクを招く。

そこで、TEEの前段にGatewayとTemporary Storageを配置する。クライアントはGatewayのエッジでコンテンツをアップロードし、TEEはGatewayと同一ネットワーク内（またはVPCエンドポイント）を経由してTemporary Storageを読み取る。TEEのエンドポイントは非公開となり、認証・レート制限・課金といった運用機能はGatewayに集約される。

登録ノード運営者の視点に立てば、あらゆるクライアントからのリクエストを受ける以上、デリケートなTEEの手前にバッファを置くことはセキュリティと帯域コストの双方の観点から自然な構成である。

### クライアント側の要求——データの秘匿

一方、クライアント側はノード運営者を無条件に信頼できない。TEE内部の処理は改ざん不可能だが、Temporary StorageやGatewayはノード運営者の管理下にあり、コンテンツを閲覧・窃取する余地がある。

クライアントはこの問題に暗号技術で対抗する。

---

### 暗号化によるEnd-to-End Encryptionの実現

クライアントは以下の情報を一つのペイロードとしてパッケージングする。

- **コンテンツ本体**（生データ）
- **帰属先ウォレットアドレス**

暗号化にはエフェメラルECDH鍵交換を用いる。クライアントは使い捨ての鍵ペアを生成し、TEEの公開鍵（ブロックチェーン上で公開されている）との鍵交換により共通鍵を導出し、対称暗号でペイロード全体を暗号化する。

帰属先ウォレットをペイロード内部に封入する設計により、ノード運営者含む全ての中間者は、宛先を改ざんすることはできない。TEEが復号して初めて、コンテンツと宛先の両方が明らかになる。

暗号化されたペイロードはTemporary Storageにアップロードされる。その後、クライアントはGatewayに対し、ペイロードのURL（Temporary Storage上の位置）と実行したい検証の種類を送る。GatewayはこれをTEEに中継するだけであり、暗号化されたペイロードの中身に触れることは物理的に不可能である。

```

  Client                    Temp Storage          Gateway              TEE
  │                            │                   │                  │
  │  1. Encrypt payload        │                   │                  │
  │     {content, wallet}      │                   │                  │
  │     with TEE public key    │                   │                  │
  │                            │                   │                  │
  │── 2. Upload encrypted ────>│                   │                  │
  │                            │                   │                  │
  │── 3. Send URL + verif. type ──────────────────>│                  │
  │                            │                   │                  │
  │                            │                   │── 4. Relay ─────>│
  │                            │                   │                  │
  │                            │<───────────────── 5. Fetch ──────────│
  │                            │─── encrypted ────────────────────── >│
  │                            │                   │                  │
  │                            │                   │          6. Decrypt
  │                            │                   │             → content
  │                            │                   │             → wallet
  │                            │                   │          7. Verify
  │                            │                   │                  │
  │                            │                   │          8. Encrypt
  │                            │                   │             response
  │                            │                   │             (same key,
  │                            │                   │              new nonce)
  │                            │                   │                  │
  │<── encrypted response ─────│───────────────────│<─────────────────│
  │                            │                   │                  │
  │  9. Decrypt response       │                   │                  │
  │     with eph_sk            │                   │                  │
  │     → signed_json          │                   │                  │
  │                            │                   │                  │
```

さらに、TEEからクライアントへの返却値（`signed_json`）も同じ共通鍵で暗号化される。ペイロードの復号時にTEEが導出した共通鍵を、異なるnonceで再利用する。クライアントはエフェメラル秘密鍵を保持しているため復号でき、Gatewayは共通鍵を知らないため中身を読めない。
これにより、クライアントとTEEの間に双方向のEnd-to-End暗号化チャネルが確立される。理想モデルにおける「クライアントと中立な計算機の直接通信」が、改ざん・閲覧不可能な形で実質的に実現される。Gatewayにできることは「素直にTEEへ中継する」か「中継を拒否する」の二択に限定される。

---

### 二段階の処理——ステートレス性の維持

TEEがコンテンツの復号・検証に成功した後、そのまま権利トークンの発行まで一気に完結できれば最も単純だが、これには問題がある。

TEEにSolanaウォレットを持たせてガス代の支払いを行わせることは、鍵管理の複雑化と外部状態への依存を招く。また、TEEの設計原則としてリクエスト間で状態を持たないステートレス性を維持したい。

加えて、権利トークンはオフチェーンストレージにデータを保持する構造であるため、`signed_json` を先にオフチェーンに保存する必要がある。

これらの制約から、登録処理を二つのフェーズに分割する。

**Phase 1: Verify（検証）**

TEEは暗号化ペイロードを復号し、コンテンツに対して指定された検証を実行する。検証結果をJSON形式でまとめ、自身の秘密鍵で署名する。この署名付きJSON（signed_json）を、ペイロード復号時に導出した共通鍵で暗号化し、クライアントに返却する。クライアントはエフェメラル秘密鍵で復号する。

**注記:** `signed_json` に時刻による有効期限は設けない。`signed_json` 内の `tee_signature` は、それを生成したTEEインスタンス（キーペア）が稼働している間のみ検証可能である。TEEが再起動され鍵がローテーションされた時点で、過去に生成された全ての `signed_json` は署名検証に失敗し、Phase 2で自動的に拒否される。この「鍵のライフサイクル＝ `signed_json` の有効期間」という設計により、信頼できないホスト時刻への依存を排除する。

**クライアントによるオフチェーンアップロード**

クライアントは、TEEが署名した `signed_json` をオフチェーンストレージ（Arweave等）にアップロードし、永続的なURIを取得する。

**Phase 2: Sign（署名・発行）**

クライアントは、オフチェーンストレージのURIをGateway経由でTEEに送信する。TEEは以下を実行する。

1. URIからJSONを取得する
2. JSON内の `tee_signature` を自身の公開鍵で検証し、自身がPhase 1で生成したものであることを確認する
3. 検証に通過した場合、cNFT発行トランザクションを構築し、自身の秘密鍵で部分署名する

TEEが部分署名したトランザクションはクライアントに返却される。クライアントは自身のウォレットで最終署名を行い、Solanaにブロードキャストする。

```
Client                    Gateway                 TEE                  Temp Storage            Off-chain Storage            Solana
  │                          │                     │                        │                         │                        │
  │  ═══ Phase 1: Verify ═══════════════════════════════════════════════════════════════════════════════════════════════════   │
  │                          │                     │                        │                         │                        │
  │── URL + verifiers ──────>│──── relay ─────────>│                        │                         │                        │
  │                          │                     │── fetch encrypted ────>│                         │                        │
  │                          │                     │<── ciphertext ─────────│                         │                        │
  │                          │                     │                        │                         │                        │
  │                          │                     │  decrypt → content + wallet                      │                        │
  │                          │                     │  run verification(s)                             │                        │
  │                          │                     │  build signed JSON                               │                        │
  │                          │                     │                        │                         │                        │
  │<── signed JSON ──────────│<─── return ─────────│                        │                         │                        │
  │                          │                     │                        │                         │                        │
  │── upload signed JSON ────────────────────────────────────────────────────────────────────────────>│                        │
  │<── URI ───────────────────────────────────────────────────────────────────────────────────────────│                        │
  │                          │                     │                        │                         │                        │
  │  ═══ Phase 2: Sign ═════════════════════════════════════════════════════════════════════════════════════════════════════   │
  │                          │                     │                        │                         │                        │
  │── URI ──────────────────>│──── relay ─────────>│                        │                         │                        │
  │                          │                     │── fetch JSON ───────────────────────────────────>│                        │
  │                          │                     │<── signed JSON ──────────────────────────────────│                        │
  │                          │                     │                        │                         │                        │
  │                          │                     │  verify tee_signature                            │                        │
  │                          │                     │  build mint tx + partial sign                    │                        │
  │                          │                     │                        │                         │                        │
  │<── partial_tx ───────────│<─── return ─────────│                        │                         │                        │
  │                          │                     │                        │                         │                        │
  │── wallet sign + broadcast ────────────────────────────────────────────────────────────────────────────────────────────────>│
  │                          │                     │                        │                         │                        │
```

---

### オフチェーンデータの事後検証性

Phase 1でTEEが生成した `signed_json` は、オフチェーンストレージに永続化された後も、以下の性質を維持する。

- **署名による保護**: 第三者はいつでもTEEの公開鍵（ブロックチェーン上で公開）を用いて署名を検証でき、データが改ざんされていないことを確認できる
- **二値的な存在**: オフチェーンデータは「存在し検証可能」か「削除されて存在しない」かの二択となる。署名を壊さずにデータを書き換えることはできないため、改ざんされた状態で存在することは不可能である

---

### 信頼の連鎖——コレクションによる封印

最後に、権利トークンに「このプロトコルによって検証された」という信頼を刻む仕組みを説明する。

Title Protocolの信頼の原点は、DAO（初期はmulti-sig: 複数の署名を要求するウォレット）が保持するCollection Authorityである。Collection Authorityとは、Metaplex標準においてコレクション（NFTのグループ）への所属を認証する権限を指す。DAOは信頼するTEEノードに対してこの権限をDelegate（委任）する。

これにより、以下の等式が成立する。

> このコレクションに属する権利トークン ＝ 信頼されたTEEによって検証・発行された権利トークン
> 

なお、権利トークンがコレクションに所属した瞬間にそのTEEの信頼が証明されるため、オフチェーンデータに記載されているTEEの公開鍵が信頼リストに存在していることを確認するフローは不要となる。

---

### 達成されたこと

以上のフローにより、権利トークン（Solana cNFT）以外のベンダーロックが存在しない状態で、以下を同時に達成する。

| 達成項目 | 内容 |
| --- | --- |
| **コンテンツの帰属** | コンテンツの権利がウォレットに紐付き、移転可能な形でブロックチェーンに記録される |
| **任意の検証結果の記録** | コンテンツの生データに基づく客観的な検証結果が、改ざん不可能な形で記録される |
| **トラストレスな事後検証** | 上記の全てが、プロトコル運営者を含む誰への信頼もなしに、第三者によって事後的に検証可能である |

---

## 1.2 検証モデル（Resolve）

### 概念モデル

登録フローが「信頼を刻む」プロセスであるのに対し、検証フローは「信頼の連鎖を辿って確認する」プロセスである。

第三者がブロックチェーン上の記録を見たとき、それが本当にプロトコルによって検証された正当なデータであることを、どのように確信できるのか。これには、信頼の原点から順に連鎖を辿る必要がある。

---

### 信頼の原点——Global Config

全ての検証の起点は、ブロックチェーン上に存在する単一のアカウント（Global Config）である。

Global Configは、DAOが管理する設定情報を保持する。最も重要なのは、プロトコル公式コレクションのアドレスである。このコレクションのAuthorityはDAOが保持し、信頼されたTEEノードにのみDelegateされる。

検証者は、まずこのGlobal Configを「信頼の原点」として受け入れる必要がある。これはプロトコルを利用する上での唯一の信頼の仮定である。Global Config自体はブロックチェーン上に存在し、その変更履歴は公開されているため、DAOのガバナンスを信頼するかどうかの判断材料は全て公開されている。

---

### 信頼の連鎖

Global Configを信頼の原点として受け入れた後、検証者は以下の連鎖を辿ることで、任意の記録の信頼性を確認できる。

```
Global Config                    信頼の原点（DAOが管理）
     │
     │ 「このコレクションがプロトコル公式である」
     ▼
Collection                       公式コレクションのアドレス
     │
     │ 「この権利トークンは公式コレクションに属している」
     ▼
cNFT (on-chain)                  ブロックチェーン上の権利トークン
     │
     │ 「この権利トークンはこのURIを指している」
     ▼
Off-chain Data                   URIに対応するオフチェーンのストレージ上のJSON
     │
     │ 「このデータはTEEの署名で封印されている」
     ▼
Verified Content Attribution     検証済みのコンテンツ帰属

```

各ステップを詳細に説明する。

**Step 1: コレクション所属の確認**

cNFTがGlobal Configで指定された公式コレクションに属しているかを確認する。

1.1で説明した通り、コレクションのAuthorityはDAOが保持し、信頼されたTEEノードにのみDelegateされている。したがって、公式コレクションに属するcNFTは、必ず信頼されたTEEによって発行されたものである。

この確認はブロックチェーン上で完結する。

**Step 2: オフチェーンデータの取得と署名検証**

cNFTはオフチェーンデータへのURIを保持している。このURIから実際のデータを取得し、その中に含まれるTEE署名を検証する。

署名検証が成功すれば、そのデータが改ざんされていないことが暗号学的に証明される。TEEが1.1のフローで生成した時点から、一切の変更が加えられていないことが保証される。

1.1で述べた「二値的な存在」——「存在し検証可能」か「削除されて存在しない」か——は、この署名検証によって実現される。

**Step 3: 所有者の特定**

署名検証に成功したオフチェーンデータには、登録時の情報（客観的なデータの検証結果）が含まれている。一方、cNFTの現在の所有者はブロックチェーン上で確認できる。

両者を組み合わせることで、「このコンテンツの現在の権利保持者はこのウォレットである」という結論が得られる。

---

### 信頼の境界——利便性レイヤー

上記の検証プロセスは、Solanaノードへの接続とオフチェーンストレージへのHTTPアクセスがあれば、誰でも独立して実行できる。これが「トラストレスな検証」の意味である。

しかし現実には、全てのユーザーが毎回この検証を自分で実行するわけではない。多くの場合、以下のいずれかを経由してデータにアクセスする。

- **DAS API**: cNFTのインデックスを提供するサービス
- **インデクサ**: プロトコル専用の検索・集約サービス

これらは全て「利便性レイヤー」である。検証の連鎖を代行し、結果を提供する。

重要な点として、利便性レイヤーは信頼の連鎖の外側にある。

**DAS API**: Digital Asset Standard API。Solana上のcNFTを効率的に検索するためのインデックスサービスが返すデータ、インデクサが構築したインデックス、SDKが提供する結果——これらは全て、上記のStep 1〜3を実行すれば独立に検証可能である。

利便性レイヤーを信頼するかどうかは、ユーザーの選択である。信頼しない場合は、自分で検証を実行すればよい。信頼する場合でも、疑わしい結果があればいつでも独立検証に戻ることができる。

この構造により、利便性とトラストレス性が両立する。

```
┌─────────────────────────────────────────────────────────┐
│  利便性レイヤー（信頼は任意）                                │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐                  │
│  │ DAS API │  │Indexer  │  │ Client  │                  │
│  └─────────┘  └─────────┘  └─────────┘                  │
└─────────────────────────────────────────────────────────┘
                        ▲
                        │ アクセス手段を提供
                        │
┌─────────────────────────────────────────────────────────┐
│  信頼の連鎖（トラストレスに検証可能）                         │
│                                                         │
│  Global Config → Collection → cNFT → Off-chain Data     │
│                                                         │
└─────────────────────────────────────────────────────────┘

```

---

### 達成されたこと

検証モデルにより、以下が実現する。

| 達成項目 | 内容 |
| --- | --- |
| **トラストレスな検証** | プロトコル運営者を含む誰への信頼もなしに、記録の正当性を第三者が独立して確認できる |
| **信頼の原点の最小化** | 信頼の仮定はGlobal Config（DAOのガバナンス）のみに限定される |
| **利便性との両立** | 日常的には利便性レイヤーを使いつつ、必要に応じていつでも独立検証に戻れる |

1.1の登録モデルと1.2の検証モデルは対称的な関係にある。登録が「信頼を刻む」プロセスであり、検証が「信頼を確認する」プロセスである。両者が揃うことで、プロトコルは完全なライフサイクルを持つ。

# 2. Core（来歴グラフ）

前セクションでは、個々のコンテンツの帰属と検証を扱う汎用的なモデルを定義した。本セクションでは、C2PA検証をCoreとして導入することで、プロトコルが単一コンテンツの帰属から「コンテンツの家系図と権利帰属」へと拡張される過程を説明する。

---

## 2.1 コンテンツの識別子

### C2PAとActive Manifest

C2PAは、コンテンツに署名付きメタデータ（**Manifest**）を付与する規格である。Manifestには、作成者、使用ツール、編集履歴などの情報が含まれる。コンテンツが編集されるたびに新しいManifestが追加され、履歴として積み重なる。**Active Manifest**とは、この履歴の中で「現在のコンテンツの状態」を表す最新のManifestを指す。

Title Protocolは、このActive Manifestの署名のSHA-256ハッシュ値をコンテンツの識別子として使用する。署名を利用する理由は、署名がManifest全体を暗号学的に要約したものであり、これをハッシュすることでコンパクトかつ一意な識別子が得られるからである。

> content_hash = SHA-256（Active Manifestの署名）
> 

この値は決定論的に算出される。同一のC2PAコンテンツからは、誰が計算しても同一のcontent_hashが得られる。TEEはC2PA署名チェーンの正当性を検証した上で、この値を計算する。

### C2PA検証が証明するもの

TEEによるC2PA検証は、以下の二つを暗号学的に確認する。

| 確認事項 | 意味 |
| --- | --- |
| 署名チェーンの正当性 | コンテンツが主張する出自（撮影機器、編集ソフト等）が改ざんされていない |
| コンテンツの同一性 | Manifestが付与された時点からコンテンツ本体が変更されていない |

これに加え、C2PAはもう一つの重要な情報を持つ。コンテンツの「素材（ingredient）」情報である。

---

## 2.2 来歴グラフの導出

### 素材情報とDAG

C2PAでは、コンテンツを合成する際に使用した素材のManifest情報を、新しいManifestに埋め込むことができる。動画を作成する際に使用した音声・画像・イラストの各Manifest情報が、完成した動画のManifestに記録される。

TEEはこの素材情報を再帰的に抽出し、有向非巡回グラフ（DAG）を構築する。

```
            ┌──────────────┐
            │  Final Video │
            │  (0xFinal)   │
            └──────┬───────┘
                   │
         ┌─────────┼─────────┐
         │         │         │
         ▼         ▼         ▼
     ┌───────┐ ┌───────┐ ┌───────┐
     │ Audio │ │ Image │ │Illustr│
     │(0xAAA)│ │(0xBBB)│ │(0xCCC)│
     └───┬───┘ └───────┘ └───────┘
         │
         ▼
     ┌───────┐
     │ Voice │
     │(0xDDD)│
     └───────┘

```

各ノードはcontent_hashで識別される。各エッジは「この素材がこのコンテンツの作成に使われた」という関係を表す。

重要な性質として、このグラフはC2PAデータから客観的・機械的に構築される。ユーザーが任意に親子関係を指定することはできない。TEEが抽出する来歴グラフは、C2PAに記録された事実そのものである。

### 来歴グラフをCoreに据える理由

セクション1のモデルは、任意の検証に適用できる汎用的なフレームワークである。CoreもExtensionも、セクション1と同じ登録・検証フローに基づいて動作する。両者を分ける理由は、記録する情報の性質にある。

来歴グラフはコンテンツ**間**の関係——誰が何を使って何を作ったか——を定義する。これは権利構造そのものである。一方、知覚ハッシュ、AI学習許諾フラグ、ライセンス種別といった情報は、個々のコンテンツ**の**性質を記述する属性である。

|  | Core | Extension |
| --- | --- | --- |
| 扱う情報 | コンテンツ間の関係（来歴グラフ） | 個々のコンテンツの性質（属性） |
| 答える問い | Who is involved? | What is it? |
| 例 | この動画の音声素材の持ち主は誰か | この画像の知覚ハッシュは何か |

来歴グラフを権利構造の基盤（Core）に据え、それ以外の検証結果を属性（Extension）として分離することで、プロトコルは「複数コンテンツ間の依存関係」と「単一コンテンツの性質」というレイヤーが異なる概念を明確に区別しながらも共通した構造で管理することができる。

---

## 2.3 グラフを伴う登録と解決

### 登録時の処理

セクション1の登録フローにおいて、TEEがコンテンツを検証する際、Core（C2PA検証）として以下の処理が行われる。

1. C2PA署名チェーンを検証する
2. Active Manifestの署名からcontent_hashを計算する
3. Manifestに含まれる素材情報を再帰的に抽出する
4. 来歴グラフ（ノードとエッジ）を構築する
5. グラフを検証結果の一部としてTEE署名で封印する

来歴グラフは `signed_json` 内に記録され、cNFTのメタデータURIを通じてオフチェーンデータとして参照可能となる。

### 遅延解決（Lazy Resolution）

来歴グラフの重要な特性として、**素材が未登録でもグラフ構造は保持される**。

具体例を示す。Aliceの素材A, Bを使って、Bobが作品Cを作成した場合。

**Bobが作品Cを登録した時点:**

```
resolve(0xHashC) →
  nodes:
    0xHashC  → owner: Bob
    0xHashA  → owner: null     ← 未登録
    0xHashB  → owner: null     ← 未登録
  edges:
    0xHashA → 0xHashC
    0xHashB → 0xHashC

```

素材A, Bの所有者は不明だが、「CはAとBから作られた」というグラフ構造はCの登録データに記録されている。

**その後、Aliceが素材Aを登録:**

```
resolve(0xHashC) →
  nodes:
    0xHashC  → owner: Bob
    0xHashA  → owner: Alice    ← 解決済み
    0xHashB  → owner: null

```

Aliceが素材Aを登録したことで、Cのグラフ上にあるAのノードに所有者が紐付く。グラフの再構築は不要である——グラフ構造はCの登録時に確定しており、変わるのは各ノードの所有者の解決状況だけである。

Aliceが素材Bも登録すれば、全ノードに所有者が紐付いた完全なグラフが返る。

### 解決フローの拡張

セクション1の抽象モデルにおける解決フローは、来歴グラフにより以下のように具体化される。

**グラフ対応:**
入力: content_hash → 出力: 来歴グラフ全体（各ノードに所有者ウォレットを含む）

具体的には以下の手順となる。

1. content_hashに対応する権利トークンを検索し、所有者を特定する
2. その権利トークンの来歴グラフから、全ての祖先ノードのcontent_hashを列挙する
3. 各祖先のcontent_hashに対して権利トークンを検索し、所有者を特定する（登録済みであれば）
4. 全ての所有者ウォレットを含む完全なグラフを返却する

これにより、「この動画を買ったら誰に払うべきか」「この作品の音声素材を作ったのは誰か」といった問いに、プログラマティックに答えられるようになる。

---

## 2.4 重複の解決

同一のcontent_hashに対して複数の権利トークンが存在する場合がある——複数のユーザーが同じコンテンツを登録した場合などである。プロトコルは以下の基準で正当な権利トークンを一意に決定する。

### 原則: 先に作成した者が優先される

「先に登録した者勝ち」ではなく「先に作成した者勝ち」である。

C2PAタイムスタンプ（RFC 3161 TSA等）は、コンテンツの作成時刻を暗号学的に証明する。プロトコルは信頼するTSA（Time Stamp Authority）のリストをブロックチェーン上で管理し、そのガバナンスはDAOが担う。

### 判定ロジック

全ての権利トークンについて、以下のルールで「作成時刻」を決定する。

| 条件 | 作成時刻の決定方法 |
| --- | --- |
| 信頼できるTSAタイムスタンプを持つ | C2PA TSAタイムスタンプを使用 |
| 信頼できるTSAタイムスタンプを持たない | Solana block time（登録時刻）を使用 |

全ての権利トークンの作成時刻を統一的に比較し、最古のものを正当な権利トークンとして選択する。

```
複数の権利トークンが存在
    │
    ▼
各トークンの「作成時刻」を決定
  - TSAあり → TSAタイムスタンプ
  - TSAなし → Solana block time
    │
    ▼
作成時刻が最古のトークンを選択
    │
    ▼
同じ作成時刻のトークンが複数あれば登録時刻が最古のトークンを選択
```

焼却（Burn）された権利トークンは権利放棄とみなし、解決対象から除外される。

この設計により、登録タイミングに依存しない判定が可能となる。先に作品を作成した者は、後から登録しても権利を主張できる。また、TSAを使用していなくても、実際に先に登録していれば権利が認められる。

---

## 2.5 モデルの実装定義

本セクション（Core）は、セクション1で定義した抽象モデルを、C2PA規格を用いて以下のように具体実装したものである。

| **抽象モデルの要素** | **Coreにおける具体的実装** |
| --- | --- |
| **検証対象** | **C2PA署名付きコンテンツの生データ**
コンテンツの生データに基づき、埋め込まれた署名チェーンとマニフェストを検証する。 |
| **識別子** | **アクティブマニフェスト署名のSHA256ハッシュ**
コンテンツの現在の状態に対応するC2PA署名のハッシュ値を、コンテンツの現在の状態に対する一意なIDとして使用する。 |
| **記録される事実** | **来歴グラフ（DAG）**
過去の全来歴、すなわち素材や過去の状態に対応する全てのマニフェスト署名を、有向非巡回グラフ構造で記録する。 |

# 3. Extension（属性の付与）

前セクションでは、C2PA検証の来歴グラフをCoreに据えることで、コンテンツの家系図と権利帰属が実現された。本セクションでは、同じ出発点から分岐し、コンテンツに任意の客観的属性を付与するExtensionを説明する。

構成は前セクションと対応している。

---

## 3.1 検証の分岐点

### 共通の前処理

ExtensionはCoreと同じ出発点を持つ。TEEがコンテンツを受け取ってから、以下の処理はCoreと完全に同一である。

1. C2PA署名チェーンを検証する
2. Active Manifestの署名からcontent_hashを計算する

ここまでの処理により、コンテンツの識別子（content_hash）が確定する。Coreでは3番目のステップとして「素材情報を再帰的に抽出し来歴グラフを構築する」が続くが、Extensionでは異なる処理に分岐する。

### 分岐: 来歴グラフ vs 属性算出

| ステップ | Core | Extension |
| --- | --- | --- |
| 1 | C2PA署名チェーンを検証 | 同左 |
| 2 | Active Manifestの署名からcontent_hashを計算 | 同左 |
| 3 | **素材情報を再帰的に抽出し来歴グラフを構築** | **WASMモジュールを実行し属性値を算出** |
| 4 | TEE署名で封印 | 同左 |

ステップ3だけが異なり、ステップ4は再び同一となる。

なお、ステップ3のExtensionにおいて、WASMへの入力は「コンテンツの生データ」に加え、クライアントが提供する補助入力（`extension_inputs`）を含む場合がある。この仕組みはセクション3.2で詳述する。

---

## 3.2 属性の導出

### WASMモジュールによる変換

Extensionにおけるステップ3は、WASM（WebAssembly）モジュールの実行である。WASMは、ブラウザやサーバー上で高速に実行可能なバイナリ形式であり、任意の言語（Rust、C等）からコンパイルできる。浮動小数点系の細かな揺れを除けば、決定論的な実行が保証されるため、同じ入力に対して常に同じ出力を返す。

WASMモジュールは、コンテンツの生データと、オプションの補助入力（`extension_inputs`）を受け取り、客観的な属性値を出力する。

> C2PAコンテンツ + extension_inputs[extension_id] → WASM → 属性値
> 

この変換は決定論的である。同じコンテンツと同じ補助入力に同じWASMを適用すれば、誰が実行しても同じ結果が得られる。

WASMの入力パターンは以下の二種類に分かれるが、パイプラインとしては同一である。

| パターン | 補助入力 | 例 |
| --- | --- | --- |
| 内部完結型 | 不要（コンテンツの生データのみで算出可能） | pHash、メタデータ抽出、ハードウェア署名検証 |
| 外部検証型 | 必要（外部で計算された結果とその証明を受け取り、WASM内で検証する） | ZK証明付きAI特徴量、外部署名付き分析結果 |

外部検証型の場合、重い計算（大規模AIモデルの推論等）は外部サービスが実行し、TEE内のWASMはその計算結果の正当性を検証するだけである。これにより、TEEのハードウェアスペックに依存せず、任意の複雑さの計算結果をExtensionとして記録できる。

### 補助入力の隔離

クライアントが複数のExtensionを同時にリクエストし、それぞれに異なる補助入力を提供する場合がある。TEEホストは `extension_inputs` をextension_idごとに分割し、各WASMには自身のIDに対応するデータのみを渡す。WASMは他のExtension用の補助入力に物理的にアクセスできない。

```
extension_inputs:
  "zkml-image-v1": { proof, features }
  "c2pa-license-v1": (なし)

→ zkml-image-v1 WASM には { proof, features } のみが渡される
→ c2pa-license-v1 WASM には補助入力は渡されない（コンテンツのみ）

```

### 属性の構造

Coreが出力する来歴グラフは、ノード（content_hash）とエッジ（素材→派生）で構成されるDAGである。Extensionが出力する属性は、キーと値のペアである。

| Core | Extension |
| --- | --- |
| DAG（ノードとエッジ） | キーと値のペア |
| 構造的 | フラット |
| コンテンツ**間**の関係 | コンテンツ**の**性質 |

例えば、pHashとは知覚ハッシュとよばれるコンテンツの見た目を表す特徴量であるが、これを属性として記録することができる。

pHashの属性を記録することにより、見た目がほぼ同じコンテンツを検出することが可能となる。これは、無断転載したコンテンツを使って利益を得る行為を防ぐ抑止力としての効果が期待される。

```
extension_id: "phash-v1"
phash: "0x1234abcd..."
```

WASMはコンテンツデータに含まれるデータに基づいた任意の処理を実行可能だが、その他の実用的な例を挙げるとすれば、ハードウェア署名の有無による撮影された未編集のコンテンツである証明の付与や、メタデータの抽出による、商用利用可否・ライセンス表示など、多くの拡張可能性が考えられる。

さらに、`extension_inputs` による補助入力を活用すれば、TEE内部では実行不可能な重い計算（大規模AIモデルによる特徴量抽出等）の結果を、外部サービスから証明付きで受け取り、WASM内でその証明を検証して記録するという構成も可能となる。この場合でもプロトコルの信頼モデルは維持される——WASMが証明の正当性を確認した上でTEE署名で封印するため、記録された属性値の信頼性は内部完結型と同等である。

### Extensionを別レイヤーにする理由

セクション2.2で述べた通り、Coreが来歴グラフを扱う理由は、それがコンテンツ間の権利構造を定義するからである。「この動画の音声素材の持ち主は誰か」という問いに答えるには、コンテンツ間の関係が必要である。

一方、Extensionが扱う属性は個々のコンテンツの性質である。「この画像の知覚ハッシュは何か」「この写真はハードウェアで撮影されたか」という問いは、そのコンテンツ単体で完結する。

この区別により、プロトコルは「権利の所在」と「コンテンツの性質」を明確に分離する。

---

## 3.3 属性を伴う登録と解決

### 登録時の処理

セクション1の登録フローにおいて、TEEがコンテンツを検証する際、Extension（WASM実行）として以下の処理が行われる。

1. C2PA署名チェーンを検証する
2. Active Manifestの署名からcontent_hashを計算する
3. 指定されたWASMモジュールを実行し、属性値を算出する。`extension_inputs` に当該extension_idのデータが存在する場合、コンテンツの生データとともにWASMへ渡す。存在しない場合、コンテンツの生データのみを渡す
4. 属性を検証結果の一部としてTEE署名で封印する

属性は `signed_json` 内に記録され、cNFTのメタデータURIを通じてオフチェーンデータとして参照可能となる。

CoreとExtensionは同一リクエストで処理できる。`processor_ids` に `["core-c2pa", "phash-v1"]` を指定すれば、来歴グラフと知覚ハッシュの両方が算出され、それぞれ別のcNFTとして発行される。

### 解決フローの拡張

セクション1の抽象モデルの解決フローは、Extension対応により以下のように具体化される。

**Extension対応:**
入力: content_hash + extension_id → 出力: 属性値

具体的には以下の手順となる。

1. content_hashとextension_idに対応するExtension cNFTを検索する
2. cNFTのメタデータURIからオフチェーンデータを取得する
3. TEE署名を検証し、属性値が改ざんされていないことを確認する
4. 属性値を返却する

これにより、「この画像の知覚ハッシュは何か」「このコンテンツはAI学習に使用できるか」といった問いに、プログラマティックに答えられるようになる。

---

## 3.4 重複の解決

同一のcontent_hashに対して同一のextension_idで複数のExtension cNFTが存在する場合がある。

WASMの決定論的な性質から、正当なExtensionは全て同一の属性値を持つはずである。しかし、複数のユーザーが独立して同じコンテンツを登録した場合、複数のcNFTが発行される。

この場合、Coreと同一のロジック（セクション2.4）で最古のものを有効と判定する。ただし、ExtensionにはTSAタイムスタンプが含まれないため、Solana block time（登録順）のみで判定される。

```
複数のExtension cNFTが存在
（同一content_hash + 同一extension_id）
    │
    ▼
Solana block time（登録順）で
最古を選択

```

第三者による重複発行が行われても、解決時に自動的に排除される。

---

## 3.5 モデルの実装定義

本セクション（Extension）は、セクション1で定義した抽象モデルを、任意のWASMによる属性抽出を用いて以下のように具体実装したものである。

| **抽象モデルの要素** | **Extensionにおける具体的実装** |
| --- | --- |
| **検証対象** | **C2PA署名付きコンテンツの生データ + オプションの補助入力（extension_inputs）：**
コンテンツの生データと、クライアントが提供する補助入力（外部計算結果やその証明等）を入力として、決定論的なWASMモジュールを実行する。補助入力が不要なWASMはコンテンツの生データのみで動作する。 |
| **識別子** | **Coreの識別子 + Extension ID：**
Coreで定義された識別子（マニフェスト署名ハッシュ）と、適用したWASMのIDの組み合わせを一意なIDとして使用する。 |
| **記録される事実** | **コンテンツデータの客観的属性：**
WASMの実行結果として算出された値（知覚ハッシュ、特徴量、フラグ等）を記録する。補助入力を使用した場合は、その入力のハッシュも併せて記録され、第三者による再現検証を可能にする。 |

# 4. 運用モデル

セクション1〜3は、プロトコルの仕組みを抽象から具体へと展開した。本セクションでは、それが現実世界でどのような価値を生み、どのような限界を持つかを明確にする。

---

## 4.1 Coreが提供する具体的な価値

### 正体

Coreが提供するものを端的に言えば、**あるコンテンツやその素材、過去の状態に対して発行されたcNFTを今持っているウォレットアドレスが分かる**、ただそれだけである。

来歴グラフを伴うことにより、そのコンテンツの素材全てのcNFTを辿った先にあるウォレットアドレスも検知可能なのである。

これ以上の意味をプロトコルのCoreは付与しない。「権利」や「所有権」といった法的概念の解釈は、プロトコルの外側——アプリケーション層や法制度——の責任である。

### これだけで可能になること

ウォレットアドレスがプログラマティックに特定できるという一点だけで、従来不可能だった処理が実現する。

**素材の自動収益分配**

複数の素材から合成されたコンテンツが売れた際、全ての素材所有者のウォレットに自動で分配できる。

```
1. 音声（Aさん）、画像（Bさん）、イラスト（Cさん）がそれぞれ登録済み
2. Dさんがこれらを使って動画を作成・登録
3. マーケットプレイスで動画が売れる
4. マーケットがTitle Protocolに問い合わせる
5. A, B, C, D のウォレットアドレスが返却される
6. マーケットの規約に従って収益を分配する

```

Title Protocolの役割は「誰に払うべきか」を返すことだけである。分配比率、手数料、ロイヤリティの計算——これらはマーケットプレイスが自身のビジネスロジックとして決定する。

プロトコルが分配ロジックを持たないことは、制限ではなく設計意図である。分配の在り方はコンテンツの種類、市場の慣行、法域によって異なる。プロトコルはウォレットアドレスという客観的事実だけを提供し、その上でアプリケーションが自由にロジックを実装できる状態を維持する。

---

## 4.2 Extensionが提供する具体的な価値

### 正体

Extensionが提供するものは、**コンテンツの生データから決定論的に導出された属性値が改ざん不可能な状態で記録されている**、ただそれだけである。

### コンテンツの真正性の証明

AI生成コンテンツの増加により、「本物」と「生成物」の区別が困難になっている。Extensionは、この混乱に対して客観的な判定基準を提供する。

C2PAのハードウェア署名チェーンを検証するWASM（例: `hardware-google`）を実行すれば、そのコンテンツがGoogle Pixel等のTitan M2チップ搭載端末で実際に撮影されたことを証明できる。この証明はTEE署名で封印され、ブロックチェーン上に永続化される。

報道機関、裁判所、保険会社——「この写真は実際にカメラで撮影されたものか」という問いに対して、第三者が独立に検証可能な回答を提供できるようになる。

### AI学習許諾の機械的な判定

C2PAの `c2pa.training-mining` アサーションには、クリエイターがAI学習への利用を許可するか否かのフラグが含まれている。`c2pa-training-v1` WASMはこのフラグを抽出し、Extension cNFTとして記録する。

AI開発者は、学習データセットの構築時に、Title ProtocolのExtensionインデックスを参照することで、クリエイターの意思を機械的に確認できる。権利情報がプログラマティックにアクセス可能な形でブロックチェーン上に存在するため、大規模なデータセットに対しても自動的にフィルタリングが可能になる。

### メタデータ消失後の追跡

例えば、pHash Extensionにより、C2PAメタデータが削除された後でもコンテンツの追跡が可能になる。

SNSで流れてきた画像から所有者を特定する、マーケットプレイスで新規出品時に既存コンテンツとの重複を検知する——これらはいずれも、content_hashではなく視覚的特徴量によるインデックスに依存する。

```
マーケットプレイスでの海賊版検知:

1. ユーザーがNFTマーケットに画像をアップロード
2. マーケットがTitle Protocol SDKで特徴量検索を実行
3. 類似度の高い既存コンテンツが見つかった場合、警告を表示
   「この画像は、登録済みのBさんの作品と類似しています」
4. 出品を許可するか拒否するかはマーケットの判断

```

### ライセンス情報の機械的な参照

C2PAのCreative Workアサーションに含まれるライセンス種別・条件を `c2pa-license-v1` WASMで抽出し、Extension cNFTとして記録する。アプリケーションは、コンテンツを利用する前にそのライセンス条件をプログラマティックに参照できる。

---

## 4.3 プロトコルの境界

Title Protocolは「登記所」であり「警察」ではない。この原則から導かれる設計上の境界を明確にする。

### コンテンツの中身に関与しない

プロトコルはContent-Agnosticである。Core Layerはコンテンツの内容（画像に何が映っているか、音声に何が含まれるか）を一切感知せず、Active Manifestの署名ハッシュのみを扱う。

違法コンテンツのフィルタリング、ヘイトスピーチの検知、年齢制限の判定——これらは全てアプリケーション層の責任である。Extension Layerは属性を付与する仕組みを提供するが、その属性に基づいてどのようなポリシーを適用するかはアプリケーションが決定する。

### 来歴ロンダリングを防がない

ユーザーがコンテンツのC2PAメタデータを削除し、視覚的に同一のコンテンツを新しい来歴で再登録することは技術的に可能であり、プロトコルはこれを検知も拒否もしない。

**防がない理由:**

防ぐためには、登録時に全ての既存コンテンツとのピクセルレベルの類似検索が必要になる。この計算コストはプロトコルの低コスト・高速という特性を破壊する。

また、類似検索に使用する特徴量の導出モデルは、コンテンツの形式・性質によって向き不向きがあり、また多種多様にわたる。プロトコルとしてこれらを管理することは大きな技術的負債となりうる。

**ロンダリングの経済的非合理性:**

来歴を削除することは、そのコンテンツから「正当な来歴」という価値を削ぎ落とす行為である。C2PAが広く普及した世界では、来歴のないコンテンツは信頼性が低いものとして扱われると考えるのが妥当である。

**アプリケーション層での対処:**

来歴ロンダリングの検知は、アプリケーション層の責任として以下の手段で対処可能である。

- 来歴の長さ・時系列の妥当性の評価
- 特定のカメラメーカー・ソフトウェアの署名のみを信頼するポリシー
- 不自然なパターンの検知
- pHash Extensionによる既存コンテンツとの類似検知

### Burnは権利の完全な放棄である

cNFTが焼却（Burn）された場合、それは権利の完全な放棄として扱われる。Burnされたコンテンツは「誰のものでもない」状態に戻り、第三者が同じコンテンツを改めて登録することを妨げない。

「間違えてBurnした場合、誰かに乗っ取られるのでは」という懸念に対して——乗っ取りには対象コンテンツのC2PA付き元データが必要であり、正規のTEE検証プロセスを通過しなければならない。元データが流出していない限り、即座の乗っ取りは困難である。

仮に「元の所有者です」という主張で乗っ取りを取り消せる仕組みを導入すると、ブロックチェーンの不可逆性という根本的な性質が失われる。プロトコルはこの原則に従い、Burnの取り消しを認めない。

### 同一コンテンツの重複登録を許容する

同一のcontent_hashに対して、複数のユーザーが独立して権利トークンを発行することは技術的に可能であり、プロトコルはこれを防止しない。

**許容する理由:**

登録時に全ての既存トークンとの重複チェックを行うことは、グローバルな状態参照を必要とし、スケーラビリティを損なう。また、分散ノード構成では、各ノードが独自のMerkle Treeを持つため、ノード間での重複検知はさらに複雑になる。

**重複の解決:**

セクション2.4で定義した重複解決ロジックにより、検証時に正当な権利トークンが一意に決定される。重複登録は解決ロジックで吸収されるため、プロトコルの整合性は維持される。

**意図的な重複登録の活用:**

この仕様を利用して、重要なコンテンツに対して意図的に複数の権利トークンを発行し、バックアップとして保持する使い方も設計意図には含まれていないが技術的には可能である。メインのトークンを誤ってBurnした場合でも、バックアップが有効な権利トークンとして機能する。どのトークンが有効かの判定は、インデクサやクライアントが解決ロジックに基づいて行う。

### プロトコルが保持するデータとDMCA

Title Protocolが永続的に保存するのは以下のデータのみである。

- Active Manifestの署名のSHA-256ハッシュ値
- 来歴グラフ構造（ノードとエッジ）
- ウォレットアドレス
- TEE Attestation Document

コンテンツの生データ（画像・音声・動画ファイル本体）はTEEのメモリ領域に一時的に保持され、検証完了後に即座に消去される。プロトコルは著作権で保護されるコンテンツ本体を複製も配信もしないため、DMCA等の著作権侵害コンテンツのホスティング責任から構造的に切り離されている。

---

## 4.4 C2PA普及への依存

Title Protocolの価値は、C2PAの普及に正比例する。これは意図的に受け入れたリスクである。

対応機器・ソフトウェアは拡大傾向にある（Sony αシリーズ、Nikon Z9、Google Pixel、Adobe Lightroom/Photoshop、ElevenLabs等）。AI生成コンテンツの増加に伴い、真正性証明への需要は高まると判断し、先行者優位の確保を目指す。

将来的にC2PAに代わる標準規格が登場した場合は、セクション1のモデルが特定の検証規格に依存しない汎用的なフレームワークであることを活かし、新規格への対応を検討する。

---

## 4.5 ノードの運用

### オープンソース化

プロトコルへのコンテンツ登録を行う計算は、登録ノードで実行される。登録ノードのプログラムは全てオープンソースとして公開されており、誰でも登録ノードを立てることが可能である。

各登録ノードは自由に課金プランを設け、開発者やエンドユーザーにプロトコルへのゲートウェイを提供することが可能である。

プロトコルのDAOによって登録ノードのTEEの公開鍵が承認されれば、そのTEEがプロトコルのコレクションにcNFTを発行する権限を委任され、正式なcNFTを発行することが可能となる。

### 分散化

初期は単一のTEEノードで運用し、段階的に複数ノードによる分散運用へ移行する。

| 効果 | 説明 |
| --- | --- |
| 単一障害点の排除 | 1台が停止しても他のノードが処理を継続 |
| 地理的分散 | ユーザーに近いノードでレイテンシを改善 |
| 検閲耐性 | 特定のノード運営者による検閲を回避 |
| 競争 | ノード間の価格・スペック競争によるサービス向上 |

# 5. データ構造

本セクションでは、プロトコルを流れるデータの具体的な形式を、時系列に沿って定義する。

---

本セクションで使用するエンコーディング形式:

| 形式 | 用途 |
| --- | --- |
| Base58 | Solanaアドレス、公開鍵等。人間が読みやすく、紛らわしい文字（0, O, l, I）を除外 |
| Base64 | バイナリデータ（暗号文、署名等）。標準的なバイナリ→テキスト変換 |

## 5.1 登録フローのデータ構造

### Step 1: クライアントが構築するペイロード（暗号化前）

クライアントは、コンテンツ本体と帰属先ウォレットを一つのペイロードにまとめる。

```json
{
  "owner_wallet": "Base58エンコードされたSolanaウォレットアドレス",
  "content": "Base64エンコードされたコンテンツバイナリ",
  "sidecar_manifest": "(Optional) Base64エンコードされた.c2paファイル",
  "extension_inputs": {
    "extension_id": {
      "(WASMが期待する任意のJSONオブジェクト)"
    }
  }
}

```

`extension_inputs` はOptionalフィールドである。キーはextension_id、値はそのWASMが期待する任意のJSONオブジェクトである。内部完結型のExtension（pHash等）のみをリクエストする場合は省略できる。

このペイロード全体（`extension_inputs` を含む）が、セクション1で説明したハイブリッド暗号化の対象となる。これにより、ノード運営者を含む全ての中間者は、どのような補助データが送られているかも知ることはできない。

---

### Step 2: 暗号化されたペイロード（Temporary Storageに保存）

暗号化後、以下の構造でTemporary Storageにアップロードされる。

```json
{
  "ephemeral_pubkey": "Base64エンコードされたX25519公開鍵（32バイト）",
  "nonce": "Base64エンコードされたAES-GCM nonce（12バイト）",
  "ciphertext": "Base64エンコードされた暗号文"
}

```

TEEは `ephemeral_pubkey` と自身の秘密鍵でECDHを実行し、共通鍵を導出して `ciphertext` を復号する。

---

### Step 3: /verify リクエスト（Client → Gateway → TEE）

```json
{
  "download_url": "Temporary Storage上の暗号化ペイロードのURL",
  "processor_ids": ["core-c2pa", "phash-v1"]
}

```

`processor_ids` は実行する検証の識別子リスト。`core-c2pa` はCore（来歴グラフ抽出）、それ以外はExtension（WASM実行）を指定する。

---

### Step 4: signed_json の構造（Core）

TEEは復号・検証を完了し、検証結果をJSONにまとめてTEE署名で封印する。

```json
{
  "protocol": "Title-v1",
  "tee_type": "aws_nitro",
  "tee_pubkey": "Base58エンコードされたEd25519公開鍵",
  "tee_signature": "Base64エンコードされた署名（payload + attributesが対象）",
  "tee_attestation": "Base64エンコードされたAttestation Document",
  "payload": {
    "content_hash": "0x...",
    "content_type": "image/jpeg",
    "creator_wallet": "Base58エンコードされたウォレットアドレス",
    "tsa_timestamp": 1735000000,
    "tsa_pubkey_hash": "0x...",
    "tsa_token_data": "Base64エンコードされたRFC 3161トークン",
    "nodes": [
      { "id": "0xCurrentHash", "type": "final" },
      { "id": "0xParentHash_A", "type": "ingredient" },
      { "id": "0xParentHash_B", "type": "ingredient" }
    ],
    "links": [
      { "source": "0xParentHash_A", "target": "0xCurrentHash", "role": "audio" },
      { "source": "0xParentHash_B", "target": "0xCurrentHash", "role": "image" }
    ]
  },
  "attributes": [
    { "trait_type": "protocol", "value": "Title-v1" },
    { "trait_type": "content_hash", "value": "0xCurrentHash" },
    { "trait_type": "content_type", "value": "image/jpeg" }
  ]
}

```

`tsa_timestamp` / `tsa_pubkey_hash` / `tsa_token_data` は、C2PAタイムスタンプが存在する場合のみ含まれる。存在しない場合は `null` または省略される。

`nodes` と `links` が来歴グラフを表現する。`nodes` の各要素はcontent_hashで識別されるコンテンツノード、`links` は素材→派生の関係を表すエッジである。

---

### Step 5: signed_json の構造（Extension）

```json
{
  "protocol": "Title-Extension-v1",
  "tee_type": "aws_nitro",
  "tee_pubkey": "Base58エンコードされたEd25519公開鍵",
  "tee_signature": "Base64エンコードされた署名（payload + attributesが対象）",
  "tee_attestation": "Base64エンコードされたAttestation Document",
  "payload": {
    "content_hash": "0xCurrentHash",
    "content_type": "image/jpeg",
    "creator_wallet": "Base58エンコードされたウォレットアドレス",
    "extension_id": "phash-v1",
    "wasm_source": "ar://WASMバイナリのArweave URI",
    "wasm_hash": "0x（TEEが実行前に計算したWASMバイナリのSHA-256ハッシュ）",
    "extension_input_hash": "(Optional) 0x（extension_inputs[extension_id]のSHA-256ハッシュ）",
    "phash": "0x..."
	}
  "attributes": [
    { "trait_type": "protocol", "value": "Title-Extension-v1" },
    { "trait_type": "content_hash", "value": "0xCurrentHash" },
    { "trait_type": "content_type", "value": "image/jpeg" }
  ]
}
```

`payload` 内の `extension_id` 以降のフィールドはWASMごとに異なる。上記はpHash WASMの例であり、他のWASMでは異なる属性フィールドが出力される。

`extension_input_hash` は、WASMが補助入力（`extension_inputs`）を使用した場合にのみ含まれる。補助入力の元データ自体はプロトコルに保存されないが、入力の提供者が元データを公開すればハッシュとの照合で完全な再現検証が可能となる。内部完結型のWASM（pHash等）では省略される。

外殻（`protocol`, `tee_type`, `tee_pubkey`, `tee_signature`, `tee_attestation`, `attributes`）はCoreと同一の構造である。

`wasm_hash` は、TEEがWASMモジュールを実行する直前にバイナリのSHA-256ハッシュを計算し、記録する値である。Global Configの `trusted_wasm_modules[].wasm_hash` と照合することで、第三者はこのExtensionが信頼されたWASMによって生成されたことを事後的に検証できる。

---

### Step 6: /verify レスポンス（TEE → Gateway → Client）

> /verifyレスポンスは、ペイロード復号時に導出した共通鍵で暗号化されて返却される。
> 

```json
{
  "nonce": "Base64エンコードされたAES-GCM nonce（12バイト）",
  "ciphertext": "Base64エンコードされた暗号文"
}
```

> クライアントがエフェメラル秘密鍵で復号した結果:
> 

```json
{
  "results": [
    {
      "processor_id": "core-c2pa",
      "signed_json": { ... }
    },
    {
      "processor_id": "phash-v1",
      "signed_json": { ... }
    }
  ]
}
```

> processor_idごとに `signed_json` が返却される。
> 

---

### Step 7: オフチェーンストレージへのアップロード

クライアントは `signed_json` をオフチェーンストレージ（CoreはArweave, Extensionは任意）にアップロードし、URIを取得する。

```
Core:      ar://abc123...
Extension: r2://def456...
```

---

### Step 8: /sign リクエスト（Client → Gateway → TEE）

```json
{
  "recent_blockhash": "Base58エンコードされたBlockhash",
  "requests": [
    {
      "signed_json_uri": "ar://abc123..."
    }
  ]
}
```

`recent_blockhash` はクライアントが `/sign` リクエスト直前に `getLatestBlockhash` RPC を呼び出して取得する。TEEはこのBlockhashを使用してトランザクションを構築し、部分署名を行う。

CoreとExtensionを同一リクエストでまとめて処理できる。複数のコンテンツを含めることも可能。

---

### Step 9: /sign における TEE の検証

TEEは各リクエストに対して以下を検証する。

1. `signed_json_uri` からJSONをフェッチ
2. JSON内の `tee_signature` を自身の公開鍵で検証（自身が生成したsigned_jsonであること）

全て成功した場合、`payload.creator_wallet` を宛先としてcNFT発行トランザクションを構築し、TEEの秘密鍵で部分署名する。

ステップ2の署名検証が、実質的な有効期限チェックを兼ねる。TEEが再起動し鍵がローテーションされた場合、旧鍵で署名されたsigned_jsonはステップ2で検証に失敗し、自動的に拒否される。

Blockhashの有効期限（約60秒〜90秒）内にクライアントが最終署名・ブロードキャストを完了しなかった場合、トランザクションは無効となる。この場合、クライアントは新しいBlockhashを取得し、`/sign` を再度呼び出す必要がある。

---

### Step 10: /sign レスポンス（TEE → Gateway → Client）

```json
{
  "partial_txs": [
    "Base64エンコードされた部分署名済みトランザクション",
    "..."
  ]
}

```

トランザクションサイズの制限により複数に分割される場合がある。

---

### Step 11: cNFT On-Chain Metadata

Solana上のcNFTに記録されるメタデータ。

**Core:**

| フィールド | 値 |
| --- | --- |
| name | `Title #` + content_hash先頭8文字 |
| symbol | `TITLE` |
| uri | オフチェーンデータのURI（ar://...） |
| collection | Title Protocol Core Collection |

**Extension:**

| フィールド | 値 |
| --- | --- |
| name | `TitleExt #` + content_hash先頭8文字 |
| symbol | Extension種別（`PHASH`, `AI-PERM` 等） |
| uri | オフチェーンデータのURI |
| collection | Title Protocol Extension Collection |

cNFTがプロトコル公式コレクションに属していることが、TEEによる検証・発行を経たことの証明となる。

---

## 5.2 検証フローのデータ構造

検証フローは、信頼の原点から順に連鎖を辿り、記録の正当性を確認するプロセスである。本セクションでは、その各ステップで参照するデータの形式を定義する。

---

### Step 1: Global Config（信頼の原点）

検証の起点となるブロックチェーン上のアカウント。Solana上のPDA（Program Derived Address）として存在する。

```json
{
  "authority": "Base58エンコードされたウォレットアドレス（DAO multi-sig）",
  "core_collection_mint": "Base58エンコードされたMintアドレス",
  "ext_collection_mint": "Base58エンコードされたMintアドレス",
  "trusted_tee_nodes": [
    {
      "signing_pubkey": "Base58エンコードされたEd25519公開鍵",
      "encryption_pubkey": "Base64エンコードされたX25519公開鍵（32バイト）",
      "encryption_algorithm": "x25519-hkdf-sha256-aes256gcm",
      "gateway_pubkey": "Base58エンコードされたEd25519公開鍵",
      "gateway_endpoint": "https://gateway.example.com",
      "status": "Active",
      "tee_type": "aws_nitro",
      "expected_measurements": {
        "pcr0": "Hex文字列（Enclave Imageのハッシュ）",
        "pcr1": "Hex文字列（カーネルのハッシュ）",
        "pcr2": "Hex文字列（アプリケーションのハッシュ）"
      }
    }
  ],
  "trusted_tsa_keys": [
    "Base64エンコードされたTSA公開鍵のSHA-256ハッシュ（32バイト）"
  ],
  "trusted_wasm_modules": [
    {
      "extension_id": "phash-v1",
      "wasm_source": "ar://...",
      "wasm_hash": "SHA-256ハッシュ"
    }
  ]
}
```

`expected_measurements` の内部構造は `tee_type` に依存する。以下に各TEEタイプの形式を示す。

**AWS Nitro Enclaves (`aws_nitro`):**

```json
"expected_measurements": {
  "pcr0": "Hex文字列（Enclave Image）",
  "pcr1": "Hex文字列（カーネル）",
  "pcr2": "Hex文字列（アプリケーション）"
}
```

**AMD SEV-SNP (`amd_sev_snp`):**

```json
"expected_measurements": {
  "measurement": "Hex文字列（ゲストVMの初期状態ハッシュ）"
}
```

**Intel TDX (`intel_tdx`):**

```json
"expected_measurements": {
  "mrtd": "Hex文字列（TD初期測定値）",
  "rtmr0": "Hex文字列（ランタイム測定レジスタ0）",
  "rtmr1": "Hex文字列（ランタイム測定レジスタ1）",
  "rtmr2": "Hex文字列（ランタイム測定レジスタ2）",
  "rtmr3": "Hex文字列（ランタイム測定レジスタ3）"
}
```

| フィールド | 用途 |
| --- | --- |
| `authority` | Global Configの変更権限を持つアドレス。初期はmulti-sig、将来的にはDAO |
| `core_collection_mint` | Core cNFTの公式コレクションを識別するMintアドレス |
| `ext_collection_mint` | Extension cNFTの公式コレクションを識別するMintアドレス |
| `trusted_tee_nodes` | 信頼されたTEEノードのリスト。登録時の暗号化と検証時の署名確認に使用 |
| `trusted_wasm_modules` | 信頼されたWASMモジュールのリスト。Extension実行時に使用 |
| `trusted_tsa_keys` | 信頼するTSA（Time Stamp Authority）公開鍵のハッシュリスト。重複解決時に使用 |
| `trusted_tee_nodes[].gateway_pubkey` | Gatewayの署名検証に使用する公開鍵。TEEはこの鍵で署名されたリクエストのみを受け付ける |
| `trusted_tee_nodes[].tee_type`  | TEEの種別。`aws_nitro`、`amd_sev_snp`、`intel_tdx` 等。Attestation Documentの検証手順と `expected_measurements` の解釈は本フィールドに依存する |
| `trusted_tee_nodes[].expected_measurements` | TEEインスタンスの期待される測定値。Attestation Documentから抽出した測定値と照合することで、TEEが正しいコードを実行していたことを事後的に検証できる。内部構造は `tee_type` ごとに異なる |

検証者はこのGlobal Configを信頼の原点として受け入れる。以降の全ての検証は、ここで定義された情報に基づいて行われる。

---

### Step 2: cNFTのコレクション所属の確認

content_hashを入力として、対応するcNFTをブロックチェーンから取得する。

**取得されるcNFTデータ:**

| フィールド | 用途 |
| --- | --- |
| `id` | cNFTの一意識別子 |
| `owner` | 現在の所有者ウォレット |
| `burnt` | 焼却済みかどうか。`true` の場合は解決対象から除外 |
| `collection.address` | 所属コレクションのMintアドレス |
| `collection.verified` | コレクション所属が検証済みかどうか |
| `content.json_uri` | オフチェーンデータへのURI |

取得したcNFTが公式コレクションに属しているかを確認する。

**確認ロジック:**

```
Core cNFTの場合:
  cNFT.collection.address == GlobalConfig.core_collection_mint
  AND cNFT.collection.verified == true

Extension cNFTの場合:
  cNFT.collection.address == GlobalConfig.ext_collection_mint
  AND cNFT.collection.verified == true

```

この確認が成功すれば、そのcNFTは信頼されたTEEによって発行されたことが保証される。

---

### Step 3: オフチェーンデータの取得

cNFTの `content.json_uri` からオフチェーンデータを取得する。

**取得されるデータ（Core）:**

```json
{
  "protocol": "Title-v1",
  "tee_type": "aws_nitro",
  "tee_pubkey": "Base58エンコードされたEd25519公開鍵",
  "tee_signature": "Base64エンコードされた署名",
  "tee_attestation": "Base64エンコードされたAttestation Document",
  "payload": {
    "content_hash": "0x...",
    "creator_wallet": "Base58エンコードされたウォレットアドレス",
    "tsa_timestamp": 1735000000,
    "tsa_pubkey_hash": "0x...",
    "tsa_token_data": "Base64エンコードされたRFC 3161トークン",
    "nodes": [ ... ],
    "links": [ ... ]
  },
  "attributes": [ ... ]
}

```

**取得されるデータ（Extension）:**

```json
{
  "protocol": "Title-Extension-v1",
  "tee_type": "aws_nitro",
  "tee_pubkey": "Base58エンコードされたEd25519公開鍵",
  "tee_signature": "Base64エンコードされた署名",
  "tee_attestation": "Base64エンコードされたAttestation Document",
  "payload": {
    "content_hash": "0x...",
    "creator_wallet": "Base58エンコードされたウォレットアドレス",
    "extension_id": "phash-v1",
    "wasm_source": "ar://...",
    "phash": "0x..."
  },
  "attributes": [ ... ]
}

```

---

### Step 4: TEE署名の検証

オフチェーンデータに含まれる `tee_signature` を検証する。

**検証ロジック:**

```
signature_target = serialize(payload) + serialize(attributes)
verify(tee_pubkey, tee_signature, signature_target) == true
```

署名検証が成功すれば、`payload` と `attributes` の内容が改ざんされていないことが暗号学的に証明される。

---

### Step 4.1: Attestation Documentの検証（オプショナル）

通常、cNFTが公式コレクションに属していること（Step 2）が、信頼されたTEEによる発行の十分な証明となる。本ステップは、DAOによるノード承認プロセス自体を信頼せず、TEEが実行していたコードの正当性まで独立に検証したい場合に実行する。

オフチェーンデータに含まれる `tee_attestation` をデコードし、`tee_type` に応じた手順で検証する。

**検証ロジック:**

```
1. tee_attestation をデコードし、Attestation Document/Reportを取得

2. tee_type に応じた証明書チェーンを検証:
   - aws_nitro:  AWS Nitro Attestation PKI ルート証明書
   - amd_sev_snp: AMD ARK → ASK → VCEK 証明書チェーン（AMD KDSから取得）
   - intel_tdx:  Intel SGX PCK 証明書チェーン（Intel PCSから取得）

3. Document/Report 内の公開鍵フィールドが
オフチェーンデータの tee_pubkey と一致することを確認

4. tee_type に応じて測定値を抽出し、
   Global Config の expected_measurements と照合:
   - aws_nitro:  PCR0, PCR1, PCR2
   - amd_sev_snp: MEASUREMENT
   - intel_tdx:  MRTD, RTMR0〜RTMR3
```

ステップ4でTEE署名の検証が成功し、かつ本ステップでAttestation Documentの検証が成功した場合、以下が暗号学的に証明される。

- そのTEEは正規のハードウェア上で動作していた
- そのTEEはGlobal Configに登録された期待通りのコードを実行していた
- そのコードがオフチェーンデータに署名した

これにより、プロトコル運営者（DAO）のノード承認判断を信頼することなく、記録の正当性を第三者が完全に独立して検証できる。

---

### Step 5: content_hashの一致確認

検索に使用したcontent_hashと、オフチェーンデータ内のcontent_hashが一致することを確認する。

**確認ロジック:**

```
query_content_hash == offchain_data.payload.content_hash
```

これにより、取得したデータが確かに目的のコンテンツに対する記録であることが保証される。

---

### Step 6: 重複解決（該当する場合）

同一のcontent_hashに対して複数のcNFTが存在する場合、セクション2.4で定義したロジックに従って正当なものを決定する。

**判定ロジック:**

```
1. 各cNFTの「作成時刻」を決定する:
   - tsa_pubkey_hash が GlobalConfig.trusted_tsa_keys に含まれる
     → tsa_timestamp を作成時刻として使用
   - 含まれない
     → solana_block_time を作成時刻として使用

2. 全cNFTの作成時刻を統一的に比較し、最古のものを選択
3. もし同じ作成時刻のトークンが重複していたら、登録時刻が最古のものを選択
```

---

### Step 7: 来歴グラフの解決（Coreの場合）

Coreの `payload.nodes` に含まれる各content_hashに対して、Step 2〜5を実行する。

**入力:**

```json
{
  "nodes": [
    { "id": "0xCurrentHash", "type": "final" },
    { "id": "0xParentHash_A", "type": "ingredient" },
    { "id": "0xParentHash_B", "type": "ingredient" }
  ]
}
```

**出力:**

```json
{
  "0xCurrentHash": {
    "owner": "Base58エンコードされたウォレットアドレス",
    "status": "resolved"
  },
  "0xParentHash_A": {
    "owner": "Base58エンコードされたウォレットアドレス",
    "status": "resolved"
  },
  "0xParentHash_B": {
    "owner": null,
    "status": "unregistered"
  }
}

```

`status: "unregistered"` は、そのcontent_hashに対応するcNFTがまだ登録されていないことを示す。セクション2.3で説明した遅延解決により、後から登録されれば自動的に解決される。

# 6. システム実装

本セクションでは、セクション1で定義した登録ノード（Gateway, Temporary Storage, TEE）の実装詳細と、各コンポーネントが公開するAPIの仕様を定義する。

---

## 6.1 コンポーネント構成

登録ノードは、以下のコンポーネントで構成される。

```
Client (SDK) → Gateway → Temporary Storage → TEE → Solana
                                              ↓
                                         Off-chain Storage
```

| コンポーネント | 役割 | リファレンス実装 |
| --- | --- | --- |
| Gateway | 認証、レート制限、ルーティング、署名付きURL発行 | Cloudflare Workers |
| Temporary Storage | 暗号化コンテンツの一時保管 | AWS S3 |
| TEE | C2PA検証、署名、Tx部分署名 | AWS Nitro Enclaves |
| オフチェーンストレージ | `signed_json` の永続保存（Coreは必須でArweave） | Arweave (via Irys) |

ノード運営者は、プロトコルの要件を満たす限り、任意のインフラストラクチャを選択できる。

---

## 6.2 Gateway

### 役割

Gatewayは、クライアントとTEEの中間に位置し、以下を担当する。

- クライアント認証（APIキー管理）
- レート制限
- Temporary Storageへの署名付きURL発行
- リクエストごとのリソース制限の付与
- TEEへのリクエスト中継
- 代行ミント（オプション）

TEEのエンドポイントは非公開であり、全てのリクエストはGateway経由で処理される。

GatewayはTEE運営者自身が、自分のTEEを外部から保護するために構築・管理するインフラである。したがってGatewayとTEEの間に敵対的な信頼関係は存在しない。

---

### Gateway認証

TEEは、外部からの直接アクセスを拒否し、信頼されたGateway経由のリクエストのみを受け付ける。これにより、万が一TEEのエンドポイントが漏洩した場合でも、第三者がGatewayを介さずにTEEにアクセスすることを防ぐ。

**認証フロー:**

```
Client → Gateway → TEE

1. Client: Gatewayにリクエストを送信
2. Gateway: リクエスト内容とresource_limitsを含む構造体を構築し、gateway秘密鍵で署名
3. Gateway: クライアントのリクエスト本文 + 署名 + resource_limits をTEEに転送
4. TEE: Global Configのgateway_pubkeyで署名を検証
5. TEE: 検証成功 → 処理実行 / 検証失敗 → リクエスト拒否
```

以下、`/verify` を例に各段階のデータを示す。

**① クライアントがGatewayに送信するリクエスト:**

```json
{
  "download_url": "Temporary Storage上の暗号化ペイロードのURL",
  "processor_ids": ["core-c2pa", "phash-v1"]
}
```

クライアントはGateway認証の存在を意識しない。後述するAPI仕様は全てこの層のインターフェースを定義する。

**② Gatewayが構築する署名対象:**

Gatewayは、クライアントのリクエスト本文をそのまま `body` に格納し、リソース制限を付加した構造体を構築する。この構造体全体をJSON正規化した上で、`gateway_pubkey` に対応する秘密鍵で署名する。

```json
{
  "method": "POST",
  "path": "/verify",
  "body": {
    "download_url": "Temporary Storage上の暗号化ペイロードのURL",
    "processor_ids": ["core-c2pa", "phash-v1"]
  },
  "resource_limits": {
    "max_single_content_bytes": 2147483648,
    "max_concurrent_bytes": 8589934592,
    "min_upload_speed_bytes": 1048576,
    "base_processing_time_sec": 30,
    "max_global_timeout_sec": 3600,
    "chunk_read_timeout_sec": 30,
    "c2pa_max_graph_size": 10000
  }
}
```

`resource_limits` は、Gatewayがリクエストごとに指定するリソース制限である。Gatewayは、クライアントの課金ティアやAPIキーに応じてこれらの値を動的に調整できる。例えば、上位プランのユーザーには `max_single_content_bytes` を引き上げ、無料ユーザーには制限を厳しくするといった運用が可能である。

`resource_limits` が省略された場合、TEEはコードにハードコードされたデフォルト値を使用する。個別フィールドの省略も可能であり、省略されたフィールドのみデフォルト値が適用される。

**③ GatewayがTEEに送信するリクエスト:**

```json
{
  "method": "POST",
  "path": "/verify",
  "body": {
    "download_url": "Temporary Storage上の暗号化ペイロードのURL",
    "processor_ids": ["core-c2pa", "phash-v1"]
  },
  "resource_limits": {
    "max_single_content_bytes": 2147483648,
    "max_concurrent_bytes": 8589934592,
    "min_upload_speed_bytes": 1048576,
    "base_processing_time_sec": 30,
    "max_global_timeout_sec": 3600,
    "chunk_read_timeout_sec": 30,
    "c2pa_max_graph_size": 10000
  },
  "gateway_signature": "Base64エンコードされたEd25519署名"
}
```

TEEは `gateway_signature` 以外の全フィールドをJSON正規化し、Global Configに登録された `gateway_pubkey` で署名を検証する。検証に成功した場合のみ `body` の内容を処理する。

この認証は `/verify` と `/sign`（`/sign-and-mint`）の全てのTEE向けリクエストに適用される。`/sign` の場合、`body` の内容が `/sign` のリクエスト本文に置き換わるだけであり、署名・検証の仕組みは同一である。

| 脅威 | 対策 |
| --- | --- |
| TEEエンドポイントの漏洩 | Gateway署名がないリクエストは拒否される |
| リクエスト改ざん | bodyを含めた署名による完全性検証 |
| リソース制限の改ざん | resource_limitsがGateway署名に含まれるため、中間者による改ざんを検知可能 |

---

以降のAPI仕様（`/upload-url`、`/verify`、`/sign`、`/sign-and-mint`）は、全て**①クライアント→Gateway間のインターフェース**を定義する。Gateway認証の署名やリソース制限の付与はGateway内部の処理であり、クライアントからは透過的である。

---

### API: POST /upload-url

Temporary Storageへのアップロード用署名付きURLを発行する。

**Request:**

```json
{
  "content_size": 12345678,
  "content_type": "image/jpeg"
}
```

**Response:**

```json
{
  "upload_url": "署名付きアップロードURL",
  "download_url": "TEEがアクセスするためのURL",
  "expires_at": 1735003600
}
```

**EDoS攻撃対策:**

署名付きURL発行時に `content-length-range` 条件を設定し、インフラ層でサイズ制限を強制する。

```jsx
// AWS S3 Presigned Post の例
const Conditions = [
  ["content-length-range", 0, 2 * 1024 * 1024 * 1024], // Max 2GB
];
```

---

### API: POST /verify

コンテンツの検証をTEEに委譲する。Gateway認証を経て、TEEにリクエストを中継する。

**Request:**

```json
{
  "download_url": "Temporary Storage上の暗号化ペイロードのURL",
  "processor_ids": ["core-c2pa", "phash-v1"]
}
```

`processor_ids` は実行する検証の識別子リスト。`core-c2pa` はCore（来歴グラフ抽出）、それ以外はExtension（WASM実行）を指定する。

**Response:**

```json
{
  "results": [
    {
      "processor_id": "core-c2pa",
      "signed_json": { ... }
    },
    {
      "processor_id": "phash-v1",
      "signed_json": { ... }
    }
  ]
}
```

processor_idごとに `signed_json` が返却される。`signed_json` の構造はセクション5.1で定義されている。

---

### API: POST /sign

署名付きJSONのURIとticketを検証し、部分署名済みトランザクションを返却する。Gateway認証を経て、TEEにリクエストを中継する。

**Request:**

```json
{
  "recent_blockhash": "Base58エンコードされたBlockhash",
  "requests": [
    {
      "signed_json_uri": "ar://..."
    }
  ]
}
```

| フィールド | 説明 |
| --- | --- |
| `recent_blockhash` | クライアントが直前に取得したBlockhash。TEEはこの値を使用してトランザクションを構築する。 |

CoreとExtensionを同一リクエストでまとめて処理できる。複数のコンテンツを含めることも可能。

**Response:**

```json
{
  "partial_txs": [
    "Base64エンコードされた部分署名済みトランザクション"
  ]
}
```

トランザクションサイズの制限により複数に分割される場合がある。

クライアントは返却された部分署名済みトランザクションに対し、自身のウォレットで最終署名を行い、Solanaにブロードキャストする。Blockhashの有効期限（約60秒〜90秒）内にブロードキャストを完了しなかった場合、トランザクションは無効となる。この場合、クライアントは新しいBlockhashを取得し、`/sign` を再度呼び出す必要がある。

---

### API: POST /sign-and-mint

`/sign` に加え、Gatewayが最終署名とブロードキャストまで代行する。クライアントはSolanaウォレットでの署名を省略でき、ガス代はGateway運営者が負担する（クレジットとして課金）。

**Request:** `/sign` と同一

**Response:**

```json
{
  "tx_signatures": [
    "ブロードキャスト済みトランザクションの署名"
  ]
}
```

---

### ノード情報の公開

クライアント（SDK）がノードを選択するために必要なスペック情報は、Gatewayが自身のAPIエンドポイントで公開する。この情報はGlobal Config（on-chain）ではなく、off-chainで管理される。

```
GET /.well-known/title-node-info
```

```json
{
  "signing_pubkey": "Base58エンコードされたEd25519公開鍵",
  "supported_extensions": ["core-c2pa", "phash-v1", "hardware-google"],
  "limits": {
    "max_single_content_bytes": 2147483648,
    "max_concurrent_bytes": 8589934592
  }
}
```

Gatewayは課金ティアごとに異なる制限を適用する場合、認証済みリクエストに対してティア別の制限情報を返却するエンドポイントを別途提供することも可能である。具体的なエンドポイント設計はノード運営者に委ねる。

---

## 6.3 Temporary Storage

### 役割

TEEに直接コンテンツを送信する方式は帯域コストや処理効率の観点から非効率であるため、一時的にコンテンツを保持するストレージを配置する。

| 項目 | 内容 |
| --- | --- |
| 要件 | TEEからセキュアにアクセス可能。検証完了後または一定時間経過後に自動削除。 |
| 暗号化 | クライアントによるE2EE暗号化済みデータのみを保存。ノード運営者も内容を閲覧不可。 |

### リファレンス実装: AWS S3

- ライフサイクルポリシーで24時間後に自動削除
- 同一リージョン内のTEE（EC2）からの転送は無料（VPC Endpoint利用時）

---

## 6.4 TEE

### 役割

TEE（Trusted Execution Environment）は、コンテンツの復号・検証・署名を行う。内部処理は暗号学的に保護され、ノード運営者を含む誰も改ざん・閲覧できない。

| 項目 | 内容 |
| --- | --- |
| 実装要件 | 外部からの改ざんを検知・拒絶できる信頼された実行環境。AWS NitroやGoogle CloudのようなVM型のTEEを推奨。SGX等のプロセス型は非推奨。 |
| 信頼モデル | リモート構成証明（Remote Attestation）により、実行コードの正当性を暗号学的に証明 |
| リファレンス実装 | AWS Nitro Enclaves |

---

### 鍵管理

TEEは2組のキーペアをTEE内部（メモリ上）でのみ生成・保持する。

| 用途 | アルゴリズム | 秘密鍵の保管場所 | 公開鍵の公開場所 |
| --- | --- | --- | --- |
| 署名用 | Ed25519 | TEEメモリ内のみ | Global Config |
| 暗号化用 | X25519 | TEEメモリ内のみ | Global Config |

両秘密鍵はTEE内部でのみ生成・保持され、外部には一切エクスポートされない。これはTEEのセキュリティモデルにより暗号学的に保証される。

**鍵管理方針（KMSなし）:**

- 両秘密鍵はメモリ上のみで管理
- TEE再起動時は新しいキーペアと新しいMerkle Treeを生成
- 新しい公開鍵はGlobal Configに登録される
- KMS（AWS Key Management Service等）は使用しない（クラウドベンダーへの信頼を排除）

---

### TEE起動シーケンス

TEEインスタンスは起動時に以下の初期化処理を実行する。全ての鍵素材はTEE内部のメモリ上でのみ生成・保持され、外部にエクスポートされない。

**Step 1: 鍵生成**

TEEは3組のキーペアを生成する。

| 用途 | アルゴリズム | 説明 |
| --- | --- | --- |
| 署名用 | Ed25519 | cNFT発行トランザクションの部分署名、signed_jsonの署名に使用 |
| 暗号化用 | X25519 | クライアントからのE2EEペイロードの復号に使用 |
| Tree用 | Ed25519 | Merkle Treeアカウントの作成に使用。create_tree命令の署名者となる |

Tree用キーペアの公開鍵がそのままMerkle Treeのアカウントアドレスとなる。Tree Config（tree_authority）はBubblegumプログラムによりMerkle Treeアドレスから決定論的にPDAとして導出されるため、TEEは外部から情報を注入されることなく、自身のTreeに関する全てのアドレスを起動時点で把握できる。

**Step 2: Merkle Tree作成（`/create-tree`）**

TEEは起動直後、`inactive` 状態で `/create-tree` エンドポイントを一度だけ公開する。

```
POST /create-tree

Request:
{
  "max_depth": 20,
  "max_buffer_size": 64,
  "recent_blockhash": "Base58エンコードされたBlockhash"
}

Response:
{
  "partial_tx": "Base64エンコードされた部分署名済みトランザクション",
  "tree_address": "Base58エンコードされたMerkle Treeアドレス",
  "signing_pubkey": "Base58エンコードされたEd25519公開鍵（署名用）",
  "encryption_pubkey": "Base64エンコードされたX25519公開鍵（暗号化用）"
}
```

TEEは署名用キーペアとTree用キーペアの両方で部分署名したcreate_treeトランザクションを返却する。ノード運営者はfee payerとして最終署名を行い、Solanaにブロードキャストする。

このエンドポイントはTEEインスタンスの生存期間中に一度だけ呼び出し可能である。二度目以降の呼び出しはエラーを返す。

**Step 3: 状態遷移**

`/create-tree` のレスポンス返却後、TEEは `inactive` → `active` に遷移し、`/verify` および `/sign`（`/sign-and-mint`）のリクエスト受付を開始する。`/create-tree` エンドポイントは無効化される。

```
TEE起動
  │
  ▼
[inactive] ── /create-tree ──> partial_tx返却
  │
  ▼
ノード運営者: 最終署名 + ブロードキャスト
  │
  ▼
[active] ── /verify, /sign 受付開始
```

TEEは `/create-tree` のトランザクションが実際にブロードキャストされたかを検証しない。ノード運営者がブロードキャストに失敗した場合、TEEは `active` 状態であるがTreeが存在しないため、`/sign` フェーズでトランザクション構築に失敗する。この場合、TEEインスタンスを再起動し、新しいキーペアとTreeで再初期化する。

**運用上の推奨事項:**

高コストのTreeを作成する場合、Blockhashの有効期限（約60〜90秒）内でのブロードキャスト失敗リスクを回避するため、Durable Transaction Nonce の使用を推奨する。

---

### ハイブリッド暗号化

セクション1で説明したE2EEの具体的なアルゴリズムを定義する。

| 用途 | アルゴリズム | 備考 |
| --- | --- | --- |
| 鍵交換 | X25519 ECDH | 高速な楕円曲線DH鍵共有 |
| 鍵導出 | HKDF-SHA256 | 共有秘密から対称鍵を導出 |
| 対称暗号 | AES-256-GCM | 認証付き暗号（AEAD） |

**暗号化フロー:**

```
Client                                          TEE
  │                                              │
  │  1. Global ConfigからTEEのencryption_pubkeyを取得
  │                                              │
  │  2. エフェメラルX25519キーペアを生成           │
  │     (eph_sk, eph_pk)                         │
  │                                              │
  │  3. shared_secret = ECDH(eph_sk, tee_pk)     │
  │                                              │
  │  4. symmetric_key = HKDF(shared_secret)      │
  │     ciphertext = AES-GCM-Encrypt(payload)    │
  │                                              │
  │  5. Upload: {ciphertext, eph_pk, nonce}      │
  │─────────────────────────────────────────────>│
  │                                              │
  │                    6. shared_secret = ECDH(tee_sk, eph_pk)
  │                                              │
  │                    7. symmetric_key = HKDF(shared_secret)
  │                       payload = AES-GCM-Decrypt(ciphertext)
  │                                              │
  │                       ... 検証処理 ...
  │                                              │
  │                    8. response_ct = AES-GCM-Encrypt(
  │                         signed_json, symmetric_key, new_nonce)
  │                                              │
  │<────────── {response_ct, new_nonce} ─────────│
  │                                              │
  │  9. signed_json = AES-GCM-Decrypt(          │
  │       response_ct, symmetric_key, new_nonce) │
  │                                              │
```

> アップロードとレスポンスの暗号化は同一の `symmetric_key` を使用し、異なるnonceを用いる。これにより追加の鍵交換なしに双方向の暗号化チャネルが実現される。`/sign` のレスポンスには暗号化を適用しない——`/sign` フェーズにはWASMのような任意処理が介在せず、返却されるのは部分署名済みトランザクション（クライアントが署名前に内容を検証可能）のみであるため、暗号化によって保護すべき情報が存在しない。
> 

---

### /verify フェーズの内部処理

GatewayからのGateway認証済みリクエストを受け取り、以下を実行する。

1. Gateway署名を検証（Global Configの `gateway_pubkey` を使用）
2. `resource_limits` が含まれていれば適用、なければデフォルト値を使用
3. `download_url` からTemporary Storage上の暗号化ペイロードを取得
4. ペイロードを復号（ハイブリッド暗号化の逆操作）
5. `processor_ids` に基づき、Core（C2PA検証＋来歴グラフ構築）およびExtension（WASM実行）を処理
6. 検証結果をJSON形式でまとめ、TEE秘密鍵で署名（`tee_signature`）
7. `signed_json` を、ステップ4で導出した共通鍵（`symmetric_key`）と新しいnonceでAES-GCM暗号化する。暗号化されたレスポンスをGateway経由でクライアントに返却する

---

### 不正WASMインジェクションに対する防御モデル

悪意あるノード運営者がTEEに偽のGlobal Configを提供し、信頼されていないWASMを実行させる攻撃を想定する。仮に不正なWASMがTEE内で実行され、`read_content_chunk` ホスト関数を通じてコンテンツの生データを読み取り、属性値としてエンコードして出力した場合でも、以下の二層防御により漏洩は阻止される。

**第1層: レスポンス暗号化**

`/verify` のレスポンスはECDH共通鍵で暗号化される。Gatewayはこの共通鍵を知らないため、レスポンスが通過する時点でノード運営者はsigned_jsonの中身（不正WASMがエンコードしたコンテンツデータを含む）を閲覧できない。

**第2層: クライアントによるwasm_hash検証**

クライアント（SDK）はレスポンス復号後、Extension signed_jsonに含まれる `wasm_hash` を、自身がSolana RPCに直接接続して取得したGlobal Configの `trusted_wasm_modules` と照合する。不一致が検出された場合、signed_jsonは破棄され、Arweaveへのアップロードは実行されない。

この防御モデルにより、TEEがGlobal Configを取得する経路（vsock経由の親インスタンス）を保護する必要がない。攻撃者が不正なWASMの実行に成功したとしても、レスポンス暗号化によりGateway通過時の傍受が不可能であり、wasm_hash検証により不正が検出される。攻撃の影響は `/verify` の失敗（DoS）に限定されるが、ノード運営者はもともとリクエスト中継を拒否できるため、追加の脅威とはならない。

なお、Core（C2PA検証・来歴グラフ構築）はWASMではなくTEEのattested code自体が実行するため、Global Config偽装の影響を受けない。

---

### /sign フェーズの内部処理

GatewayからのGateway認証済みリクエストを受け取り、各リクエストに対して以下を検証する。

1. `signed_json_uri` からJSONをフェッチ
2. JSON内の `tee_signature` を自身の公開鍵で検証（自身が生成したsigned_jsonであること）

全て成功した場合、`payload.creator_wallet` を宛先としてcNFT発行トランザクションを構築し、TEEの秘密鍵で部分署名する。

ステップ2の署名検証が、実質的な有効期限チェックを兼ねる。TEEが再起動し鍵がローテーションされた場合、旧鍵で署名されたsigned_jsonはステップ2で検証に失敗し、自動的に拒否される。

**TEE再起動とフェーズ間の整合性:**

Phase 1完了後、Phase 2実行前にTEEが再起動した場合、新しいキーペアでは旧signed_jsonの `tee_signature` を検証できない。この場合、`/sign`はエラーを返す。クライアントは別のTEEノードを試行するか、Phase 1からやり直すことで対処できる。TEEがステートレスであるため、やり直しに特別な手続きは不要である。

---

### /sign フェーズでの防御（Verify on Sign）

`/sign` エンドポイントでも、オフチェーンストレージからJSONを取得する際に防御を適用する。

```
攻撃シナリオ:
1. 攻撃者がPhase 1で正規のsigned_jsonを取得
2. signed_json_uri に巨大ファイル（または無限ストリーム）のURLを指定
3. TEEがfetch時にOOMまたはハング
```

**対策:**

- JSON取得時にも `tokio::io::take` でサイズ制限（例: 1MB上限）
- チャンク単位のRead Timeout
- Content-Lengthヘッダーの事前検証

---

### メモリ管理

C2PA検証（c2pa-rs）はコンテンツ全体をメモリ上に保持する必要がある。大容量コンテンツに対応するため、以下の三層防御を採用する。

| 攻撃ベクトル | 防御手段 | 仕組み |
| --- | --- | --- |
| Zip Bomb | `tokio::io::take` | 宣言サイズを超えるデータの読み取りを物理的に遮断 |
| Reservation DoS | 漸進的重み付きセマフォ予約 | 実際に受信したデータ量に応じてのみメモリを確保 |
| Slowloris | チャンク単位のRead Timeout | 一定時間データが到着しなければ接続を切断 |

---

### 漸進的重み付きセマフォ予約（Incremental Reservation）

前もって取得しておいたコンテンツのサイズ（ `content_size` ）分のメモリを処理開始時に一括予約する方法には、以下の脆弱性がある。

**攻撃シナリオ: Reservation DoS**

```
攻撃者が content_size: 2GB を宣言
→ TEEが2GB分のセマフォを予約
→ 攻撃者は1バイトも送信せずコネクションを維持
→ 他の正規ユーザーがメモリ不足で処理拒否される
```

**解決策: 漸進的重み付きセマフォ予約**

メモリ予約を「宣言時」ではなく「実際のデータ受信時」に行う。

```
1. クライアントが content_size: 2GB を宣言
2. TEEは予約せず、ストリーミング読み取りを開始
3. 64KBチャンクを受信するたびに、64KB分のセマフォを予約
4. 予約失敗（メモリ上限到達）→ 即座に接続切断
5. 全データ受信完了 → 宣言サイズと実受信サイズを照合
```

```rust
// 疑似コード
const CHUNK_SIZE: usize = 64 * 1024; // 64KB

async fn stream_with_incremental_reservation(
    stream: impl AsyncRead,
    declared_size: usize,
    semaphore: &Semaphore,
) -> Result<Vec<u8>> {
    let mut buffer = Vec::new();
    let mut total_reserved = 0;

    // 宣言サイズを超えるデータの読み取りを物理的に遮断
    let mut limited = stream.take(declared_size as u64);

    loop {
        // チャンク単位のRead Timeout（Slowloris対策）
        let chunk = timeout(
            Duration::from_secs(30),
            read_chunk(&mut limited, CHUNK_SIZE)
        ).await??;

        if chunk.is_empty() {
            break; // EOF
        }

        // 実際に受信したデータ量に応じてのみメモリを予約
        let permit = semaphore
            .try_acquire_many(chunk.len() as u32)
            .map_err(|_| Error::MemoryLimitExceeded)?;
        permit.forget(); // 処理完了まで保持

        total_reserved += chunk.len();
        buffer.extend(chunk);
    }

    Ok(buffer)
}
```

---

### 動的グローバルタイムアウト（Dynamic Global Timeout）

漸進的重み付きセマフォ予約とチャンク単位のタイムアウトだけでは、攻撃者が極めて低速（例: 64kB/29秒）で転送を継続し、長期間リソースを占有する攻撃（Slow Write DoS）を防げない。
これを防ぐため、TEEはリクエストされたコンテンツサイズとGatewayからリクエストに付与された `resource_limits` のパラメータに基づき、リクエストごとの「Global Timeout」を動的に計算・適用する。`resource_limits` が省略された場合はTEEコードにハードコードされたデフォルト値を使用する。

計算ロジック:

$$

Timeout = \min(MaxLimit, \quad BaseTime + \frac{ContentSize}{MinSpeed})

$$

---

### 処理上限の管理

TEEコードにはデフォルトのリソース制限がハードコードされている。Gatewayはリクエストごとに `resource_limits` を付与することで、これらの値を上書きできる。

| パラメータ | デフォルト値 | 説明 |
| --- | --- | --- |
| `max_single_content_bytes` | 2GB | 単体コンテンツの最大サイズ |
| `max_concurrent_bytes` | 8GB | 同時処理可能な合計データ量 |
| `min_upload_speed_bytes` | 1MB/s | 動的タイムアウト計算に使用する最低転送速度 |
| `base_processing_time_sec` | 30 | 接続確立や検証開始にかかる固定オーバーヘッド時間 |
| `max_global_timeout_sec` | 3600 | 処理を強制終了する絶対的な最大時間 |
| `chunk_read_timeout_sec` | 30 | 次のデータチャンクが到着するまでの最大待機時間 |
| `c2pa_max_graph_size` | 10000 | C2PAマニフェストのグラフの読み込み可能な最大サイズ
これはノード+エッジの最大値であり、計算中にこの最大サイズを超えるとエラーを返す |

---

## 6.5 Merkle Tree

### Sharded Tree アーキテクチャ

Title Protocolでは、各TEEノードが独自のMerkle Treeを持つ構成を採用する。

| 項目 | 内容 |
| --- | --- |
| 構成 | TEE 1台につき、Core用Tree 1つ + Extension用Tree 1つ |
| メリット | 同時書き込み競合なし、無限にスケール可能、障害の隔離 |
| Tree寿命 | TEEの秘密鍵が失われると、そのTreeへの新規書き込みは不可能。既存cNFTは永続的に有効。 |

### Tree設計

| 用途 | Depth | 最大発行数 | 初期コスト (SOL) | 初期コスト (円換算) |
| --- | --- | --- | --- | --- |
| 開発/テスト | 14 | 16,384 | ~0.16 | ~4,000円 |
| 小規模運用 | 20 | 1,048,576 | ~1.2 | ~30,000円 |
| 本番安定版 | 26 | 67,108,864 | ~14 | ~350,000円 |
| 大規模運用 | 30 | 1,073,741,824 | ~220 | ~5,500,000円 |

※ 円換算は1 SOL = 25,000円で試算

### Depthの選定基準

```
Depth = ceil(log2(想定発行数)) + バッファ

例: 100万枚を想定
  → log2(1,000,000) ≈ 20
  → Depth 20で1,048,576枚まで対応
  → 余裕を持たせるならDepth 22（約400万枚）
```

### Tree枯渇時の対応

TEEの秘密鍵とTreeは1対1で紐付くため、新しいTreeの作成には新しいTEEインスタンス（または既存インスタンスの再起動）が必要となる

```
Tree A (Depth 20) → 100万枚発行 → 枯渇
                           ↓
Tree B (Depth 20) → 新規発行はこちらへ
```

既存のcNFT（Tree A）は引き続き有効である。

---

## 6.6 インデクサ

### 役割

cNFTのインデックスを構築し、複雑なクエリに対応した柔軟な検索を可能にする。

### 構成

| レイヤー | 役割 |
| --- | --- |
| Webhook | Mint/Burnイベントをリアルタイムに検知してDBに反映 |
| ポーリング | Webhookの欠落を補完するため、定期的にDAS APIをポーリング |

### リファレンス実装

Helius Webhooks + Supabase（PostgreSQL + Edge Functions）によるサーバーレス構成。常時稼働サーバーが不要であり、コストは実際に発生したイベント数にのみ比例する。

---

## 6.7 SDK

SDKは以下のコア関数を提供する。

### discoverNodes(options?)

Global Configから信頼されたTEEノードの一覧を取得し、各ノードのGatewayエンドポイントからスペック情報を収集する。

```tsx
const nodes = await sdk.discoverNodes({
  status: 'Active',
  minSingleContentBytes: 100 * 1024 * 1024,
});
// 1. Global Config から trusted_tee_nodes（status: Active）を取得
// 2. 各ノードの gateway_endpoint/.well-known/title-node-info にアクセス
// 3. minSingleContentBytes 等の条件でフィルタリング
// Returns: TeeNodeInfo[]
```

### upload(content, targetNode)

指定したTEEノードのGatewayにコンテンツをアップロードする。内部でE2EE暗号化を実行する。

```tsx
const upload = await sdk.upload(contentBuffer, targetNode);
// Returns: { downloadUrl: string, sizeBytes: number }
```

### register(options)

コンテンツの検証・メタデータ保存・cNFT発行を実行する。

```tsx
const result = await sdk.register({
  contentUrl: upload.downloadUrl,
  owner: walletAdapter,
  targetNode: node,
  processorIds: ['core-c2pa', 'phash-v1'],
  extensionInputs: {
    // Optional: 補助入力が必要なExtensionのみ指定
    // 'zkml-image-v1': {
    //   proof: proofBuffer,
    //   claimed_features: featuresBuffer
    // }
  },
  delegateMint: false,
  storage: {
    core: { gateway: 'https://node2.irys.xyz', token: 'solana' },
    extension: { type: 'arweave' }
  }
});
```

`extensionInputs` はOptionalパラメータである。キーはextension_id、値はそのWASMが期待する任意のオブジェクトである。SDKは内部でこれをペイロードの `extension_inputs` フィールドに含め、E2EE暗号化を適用する。内部完結型のExtensionのみをリクエストする場合は省略できる。

**内部処理フロー:**

1. エフェメラルキーペア生成、ペイロード暗号化、Temporary Storageへアップロード
2. `/verify` 呼び出し
3. 暗号化レスポンスをエフェメラル秘密鍵で復号
4. Extension signed_jsonに含まれる `wasm_hash` を、SDKが直接Solana RPCから取得したGlobal Configの `trusted_wasm_modules` と照合（**セキュリティクリティカル**——後述）
5. signed_jsonをオフチェーンストレージにアップロード
6. `/sign` 呼び出し
7. partial_txの内容を検証（後述）、ウォレット署名、ブロードキャスト

**`delegateMint: false` の場合:**

```tsx
// Returns: {
//   contents: Array<{ contentHash, storageUri, extensions }>,
//   partialTxs: string[]
// }
// クライアントが署名・ブロードキャスト
```

**`delegateMint: true` の場合:**

```tsx
// Returns: {
//   contents: Array<{ contentHash, storageUri, cNftId, extensions }>,
//   txSignatures: string[]
// }
```

### resolve(contentHash)

content_hashに対応するcNFTと来歴グラフを解決する。

```tsx
const result = await sdk.resolve(contentHash);
// Returns: {
//   owner: string,
//   provenanceGraph: { nodes, links },
//   extensions: Array<{ extensionId, data }>
// }
```

### **SDKによるセキュリティ検証**

SDKは、TEEから受信したデータに対して以下の検証を実行する。これらは利便性のためのユーティリティではなく、プロトコルのセキュリティモデルを維持するための必須要件である。

**wasm_hash検証（/verify レスポンス復号直後）:**

Extension signed_jsonに含まれる `wasm_hash` を、SDKが直接Solana RPCに接続して取得したGlobal Configの `trusted_wasm_modules` と照合する。不一致の場合、当該signed_jsonを破棄し、Arweaveへのアップロードを中止する。

この検証はE2EEの安全性にとってセキュリティクリティカルである。悪意あるノード運営者が不正なWASMをTEEに実行させた場合、レスポンス暗号化がGateway通過時の傍受を防ぎ、本検証がArweaveへの永続化を防ぐ。この二層防御の詳細はセクション6.4「不正WASMインジェクションに対する防御モデル」で説明している。

**トランザクション検証（/sign レスポンス受信後、ウォレット署名前）:**

1. トランザクションに含まれるcontent_hashが、自分がアップロードしたコンテンツのハッシュと一致するか
2. 署名者がGlobal Configの信頼リストに含まれるか

これにより、Gatewayが悪意を持ってトランザクションを改ざんしても検知・拒否できる。

# 7. WASM実装詳細

---

## 7.1 安全性確保

WASMモジュールはTEE内のサンドボックス（extism）で実行される。

| 制限 | 目的 |
| --- | --- |
| Fuel制限 | 命令実行数の上限（無限ループ防止） |
| Memory制限 | メモリ使用量の上限（OOM防止） |
| catch_unwind | パニックをキャッチし、Core処理への影響を遮断 |

### 処理順序

TEE内部の処理順序として、Core（C2PA検証）が先に実行され、メモリが解放された後にExtensionのWASMが実行される。これにより、Extensionの暴走がCoreの処理を阻害することはない。

### 補助入力の分配

ペイロードに `extension_inputs` が含まれる場合、TEEホストは以下の手順でWASMへの入力を構成する。

1. ペイロードを復号し、`content`、`owner_wallet`、`extension_inputs` を取得する
2. 各Extensionの実行時に、`extension_inputs[当該extension_id]` が存在するか確認する
3. 存在する場合: コンテンツの生データと当該extension_idの補助入力のみをWASMに渡す
4. 存在しない場合: コンテンツの生データのみをWASMに渡す

この分配はTEEホスト（Rust側）で行われる。各WASMは自身のextension_idに対応する補助入力にのみアクセスでき、他のExtension用の補助入力には物理的にアクセスできない。これにより、WASM間の相互干渉やインジェクション攻撃をホスト層で遮断する。

### WASMからのコンテンツアクセス

大容量コンテンツ（数百MB〜数GB）を処理する場合、コンテンツ全体をWASMの線形メモリにコピーすることは非効率である。

TEEは、WASMモジュールがホスト関数を通じてコンテンツにチャンク単位でアクセスできる仕組みを提供する。

**Pull型アクセスパターン:**

```
WASM                              TEE Host
  │                                  │
  │  read_content_chunk(0, 64KB)     │
  │─────────────────────────────────>│
  │<─────────────────────────────────│
  │         64KB chunk               │
  │                                  │
  │  read_content_chunk(64KB, 64KB)  │
  │─────────────────────────────────>│
  │<─────────────────────────────────│
  │         64KB chunk               │
  │                                  │
  │  ... (必要な分だけ繰り返し)        │
  │                                  │

```

この設計により：

- WASMの線形メモリ使用量を最小化
- 漸進的重み付きセマフォ予約との整合性を維持
- ストリーム処理的な属性抽出（pHash計算等）が可能

ホスト関数の具体的なシグネチャは実装に委ねるが、現時点ではExtismの利用を検討している。

### WASMからの補助入力アクセス

`extension_inputs` による補助入力が提供されている場合、WASMはホスト関数を通じてその内容を取得できる。

```
WASM                              TEE Host
  │                                  │
  │  get_extension_input()           │
  │─────────────────────────────────>│
  │<─────────────────────────────────│
  │    extension_inputs[extension_id]│
  │    のJSON全体                     │
  │                                  │

```

補助入力が存在しない場合（内部完結型WASMの場合）、ホスト関数はnullを返す。

---

### 暗号プリミティブホスト関数

WASMが大容量コンテンツに対して暗号学的な計算（ハッシュ、HMAC等）を行う必要がある場合、WASM内部の純粋なソフトウェア実装では性能上の制約が生じる。特に外部検証型Extension（ZK証明の検証等）では、コンテンツ全体のハッシュをBinding確認に使用するケースがあり、数百MB〜数GBのデータに対するハッシュ計算が必要となる。

これを効率的に実現するため、TEEホストは暗号プリミティブをホスト関数として提供する。

**設計原則:**

ホスト関数のインターフェースは `read_content_chunk` と同一のアドレッシングパターンを採用する。WASMは計算対象のデータを引数として渡すのではなく、TEEホストメモリ上のコンテンツに対するオフセットと長さのみを指定する。TEEホストは指定範囲のデータに対してネイティブ速度で暗号処理を実行し、結果のみをWASMに返却する。

これにより、コンテンツデータがWASMリニアメモリとTEEホストメモリの間を往復することはない。

```
WASM                                    TEE Host
  │                                        │
  │  hash_content("sha256", 0, 全長)        │
  │───────────────────────────────────────>│
  │                                        │  ホストメモリ上のコンテンツに対して
  │                                        │  ネイティブ速度でSHA-256を計算
  │<───────────────────────────────────────│
  │          32バイトのハッシュ値              │
  │                                        │
```

**提供する関数:**

| 関数 | 引数 | 戻り値 | 説明 |
| --- | --- | --- | --- |
| `hash_content` | algorithm, offset, length | ハッシュ値のバイト列 | 指定範囲のコンテンツに対するハッシュを計算 |
| `hmac_content` | algorithm, key, offset, length | MACのバイト列 | 指定範囲のコンテンツに対するHMACを計算 |

`offset` と `length` は `read_content_chunk` と同一の座標系を使用する。すなわち、TEEホストが保持するコンテンツの生データ（C2PA署名付きコンテンツ、または署名なしコンテンツ＋オプションのサイドカー）に対するバイトオフセットと長さである。

**サポートするアルゴリズム:**

| algorithm識別子 | アルゴリズム | 出力サイズ |
| --- | --- | --- |
| `sha256` | SHA-256 | 32バイト |
| `sha384` | SHA-384 | 48バイト |
| `sha512` | SHA-512 | 64バイト |
| `keccak256` | Keccak-256 | 32バイト |

サポートアルゴリズムの追加はTEEコードの更新に伴い行われる。WASMが未サポートのアルゴリズムを指定した場合、ホスト関数はエラーを返す。

**WASMリニアメモリ上のデータに対する暗号計算:**

ホスト関数はTEEホストメモリ上のコンテンツデータにのみ作用する。WASMリニアメモリ上のデータ（補助入力のパース結果、中間計算値等）に対する暗号計算は、WASMに含まれるソフトウェア実装で処理する。補助入力は通常小さなデータ（証明、署名、メタデータ等）であるため、性能上の問題は生じない。

---

## 7.2 WASMの透明性

WASMバイナリはArweave上に公開・永続化される。Extension cNFTのオフチェーンデータには、実行されたWASMのArweave URI（`wasm_source`）が記録される。

第三者は以下の手順で属性値を独立検証できる。

1. `wasm_source` からWASMバイナリを取得
2. 対象コンテンツに対してWASMを実行
3. 出力された属性値とオフチェーンデータ内の値を比較

---

## 7.3 WASMモジュールのガバナンス

### 現行（Phase 1）

プロトコル公式のWASMモジュールのみが利用可能である。公式WASMのリストはGlobal Configの`trusted_wasm_modules`で管理される。

TEEは、リクエストされた`extension_id`がGlobal Configに登録されていることを確認し、登録されていない場合はリクエストを拒否する。これにより、任意のWASMがTEE内で実行されることを防ぐ。

```
/verify リクエスト
    │
    ▼
processor_ids に含まれる各 extension_id について
    │
    ▼
Global Config の trusted_wasm_modules に存在するか？
    │                    │
   Yes                  No
    │                    │
    ▼                    ▼
WASM実行           エラーを返却

```

### 将来（Phase 2以降）

サードパーティによるWASM提出・審査プロセスの導入を検討する。審査基準として以下を想定する。

| 基準 | 説明 |
| --- | --- |
| 決定論性 | 同一入力に対して常に同一出力を返すこと |
| 実行効率 | Fuel/Memory制限内で完了すること |
| セキュリティ | 悪意のある動作を含まないこと |
| 有用性 | プロトコルのユースケースに貢献すること |
| 入力検証の義務 | `extension_inputs` を使用するWASMは、補助入力とコンテンツの因果関係を検証するロジックを含まなければならない |

`extension_inputs` を使用するWASMに対しては、以下の二点がコード上で確認できることを追加の審査基準とする。

1. 補助入力の正当性を検証するロジック（ZK証明の検証、署名の検証等）が、**コンテンツのハッシュまたは生データを検証の入力として使用**していること。これにより、補助入力がそのコンテンツに対して生成されたものであることが保証される
2. 検証に失敗した場合にエラーを返し、属性値を出力しないこと

補助入力を検証なしにそのまま出力するWASMは、「事実の刻印」ではなく任意データの書き込みとなるため、承認しない。

具体的な審査プロセス、提出方法、更新ポリシーはDAOのガバナンスに委ねる。

---

## 7.4 公式WASMセット

| WASM ID | 入力ソース | 出力 |
| --- | --- | --- |
| phash-v1 | ピクセルデータ | 画像の知覚ハッシュ値 |
| hardware-google | C2PA署名チェーン | ハードウェア撮影証明（Titan M2等） |
| c2pa-training-v1 | c2pa.training-mining アサーション | AI学習許可/禁止フラグ |
| c2pa-license-v1 | Creative Work アサーション | ライセンス種別・条件 |

全てのWASMは「C2PAコンテンツから導出可能な属性」を対象とする。

WASMモジュールはコンテンツデータのアクセスに `read_content_chunk` を、大容量データに対する暗号計算に `hash_content` 等のホスト関数を使用できる。外部検証型WASMにおけるBinding確認（補助入力がこのコンテンツに対して生成されたものであることの検証）には、`hash_content` によるコンテンツハッシュの計算とWASM内での照合を組み合わせる方式が推奨される。

---

## 7.5 バージョン管理

WASMのバージョニングは `phash-v1` → `phash-v2` のように自然に行える。

C2PA実装ごとのメタデータ記法の差異は、Global ConfigでWASMバイナリの参照先を更新することで吸収する。古いWASMで発行されたExtension cNFTは引き続き有効であり、新しいWASMは新規発行にのみ適用される。

---

# 8. ガバナンス

---

## 8.1 Global Configの管理

Global Configの変更権限は `authority` フィールドで指定されたアドレスが持つ。

| フェーズ | 管理方式 |
| --- | --- |
| Phase 1 | 単一ウォレット（開発者が迅速に対応） |
| Phase 2 | マルチシグ（Squads等による合議制） |
| Phase 3 | DAO（分散型ガバナンスへ完全移行） |

---

## 8.2 TEEノードの追加・削除

### 追加時

1. DAOが新しいTEEノードの情報（signing_pubkey, encryption_pubkey, gateway_pubkey等）を `trusted_tee_nodes` に追加
2. 同時に `core_collection_mint` と `ext_collection_mint` のCollection Authorityを `signing_pubkey` へDelegate

### 削除時（通常）

1. TEEノードが停止（秘密鍵が消滅）
2. DAOが `trusted_tee_nodes` から該当エントリを削除
3. 既存のcNFTは有効なまま維持

### 削除時（不正発覚）

1. DAOがそのTEEのTreeに含まれる全cNFTを一括Unverify（認証剥奪）
2. `trusted_tee_nodes` から該当エントリを削除

---

## 8.3 TSA Trust Listの管理

信頼するTSA（Time Stamp Authority）の公開鍵ハッシュは `trusted_tsa_keys` で管理される。

**初期Trust List:**

| TSA | 説明 |
| --- | --- |
| DigiCert Timestamp Authority | RFC 3161準拠 |
| GlobalSign TSA | RFC 3161準拠 |
| Apple Timestamp Service | RFC 3161準拠 |
| Google C2PA Core Time-Stamping ICA G3 | オンデバイスTSA |
| Adobe Document Trust Services | RFC 3161準拠 |

TSAの追加・削除はDAOの承認を経て実行される。C2PA公式Trust Listを参照しつつ、Title Protocol独自のガバナンスで管理する。

---

# 9. コスト設計

---

## 9.1 1コンテンツあたりのコスト

### バッチミント

Solanaトランザクションのサイズ制限（1232バイト）内で、複数のMint命令を格納できる。

| バッチサイズ | トランザクション数 | 1枚あたりのBase Fee |
| --- | --- | --- |
| 1枚 | 1 | ~$0.00075 |
| 5枚 | 1 | ~$0.00015 |
| 10枚 | 1 | ~$0.000075 |
| 50枚 | 5 | ~$0.000075 |

**制約:**

- 1トランザクションあたり最大5-8枚程度（cNFTのメタデータサイズに依存）
- 同一Treeへの書き込みは直列化が必要

### 具体的なコスト試算（円換算）

1 SOL = 25,000円、1 USD = 150円で試算。

| 操作 | コスト (USD) | コスト (円) |
| --- | --- | --- |
| 単発ミント | ~$0.00082 | ~0.12円 |
| バッチミント（10枚） | ~$0.0015 | ~0.23円（0.023円/枚） |
| Tree作成（Depth 20） | ~$30 | ~4,500円 |
| Tree作成（Depth 26） | ~$350 | ~52,500円 |

### 月間運用コストの目安

| 規模 | 月間発行数 | ミントコスト | インフラコスト | 合計 |
| --- | --- | --- | --- | --- |
| 小規模 | 1,000枚 | ~$1 | ~$50 | ~$51 |
| 中規模 | 100,000枚 | ~$15 | ~$200 | ~$215 |
| 大規模 | 1,000,000枚 | ~$150 | ~$500 | ~$650 |

※ インフラコストはAWS Nitro Enclaves + S3 + Cloudflare Workersの概算

---

## 9.2 課金モデル

| 操作 | 課金 | 理由 |
| --- | --- | --- |
| Read（検証・検索） | 無料 | 誰でも自由に検証可能であるべき |
| Write（登録） | クレジット消費 | TEEリソースの利用に対する対価 |

### クレジット制

代行ミントの有無やExtensionの組み合わせでコストが異なるため、操作ごとにクレジットを消費する従量課金を採用する。

**クレジット消費例:**

| 操作 | 消費クレジット |
| --- | --- |
| verify + sign | 1 credit |
| verify + sign-and-mint | 4 credit（ガス代込み） |

**クレジット購入プラン例:**

| プラン | 月額 | 付与クレジット | レート制限 |
| --- | --- | --- | --- |
| Free | $0 | 500 | 5 req/min |
| Creator | $5 | 5,000 | 60 req/min |
| Startup | $50 | 100,000 | 300 req/min |
| Business | $300 | 1,000,000 | 1,000 req/min |

### 失敗時のクレジット消費

トランザクション失敗時（ネットワーク混雑、Blockhash期限切れ等）であっても、TEEリソースは消費されているため、クレジットの返金は行わない。

| 状況 | クレジット消費 |
| --- | --- |
| verify成功 → sign成功 → broadcast成功 | 消費 |
| verify成功 → sign成功 → broadcast失敗 | 消費 |
| verify失敗（不正なC2PA等） | 消費 |

クライアントは、broadcast失敗時に新しいBlockhashを取得して`/sign`を再度呼び出すことができる。この場合、追加のクレジットが消費される。

---

# 10. ロードマップ

| フェーズ | 内容 | 時期 |
| --- | --- | --- |
| Phase 1 | Core・Extension実装、メインネットデプロイ | 2026 Q1 |
| Phase 2 | SDK公開、開発者向けドキュメント整備 | 2026 Q2 |
| Phase 3 | DAOによるTrust List管理 | 2026 Q2 |
| Phase 4 | 複数TEEノードによる分散化 | 2026 Q3 |

---

# 11. まとめ

Title Protocolは、C2PAが解決した「来歴」「同一性」に加え、「帰属」を解決することで、デジタルコンテンツに完全なアイデンティティを付与するプロトコルである。

**アーキテクチャの特徴:**

| 特徴 | 説明 |
| --- | --- |
| 汎用モデル | セクション1の抽象モデルは特定の検証規格に依存しない |
| Core/Extension分離 | 権利構造（来歴グラフ）と属性（WASM出力）を明確に区別 |
| E2EE | ノード運営者を含む全ての中間者からコンテンツと宛先を秘匿 |
| ステートレスTEE | リクエスト間で状態を持たず、スケーラビリティを確保 |
| トラストレス検証 | Global Configのみを信頼の原点とし、全ての記録を第三者が独立検証可能 |

**プロトコルの境界:**

| する | しない |
| --- | --- |
| コンテンツの帰属を記録 | コンテンツの中身を判断 |
| 来歴グラフを構築 | 来歴ロンダリングを検知 |
| 属性を付与する仕組みを提供 | 属性に基づくポリシーを強制 |
| ウォレットアドレスを返す | 収益分配ロジックを実装 |

プロトコルは「登記所」であり「警察」ではない。客観的事実の記録と検証に徹し、その上でアプリケーションが自由にロジックを実装できる状態を維持する。